SimpleButtonMorph subclass: #Boton	instanceVariableNames: 'bloqueAccion'	classVariableNames: ''	package: 'TPO-Visual'!!Boton methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/4/2024 21:26'!mouseAction: aBlock"La instrucción almacena en la variable bloqueAccion el bloque proporcionado como parámetro y especifica la acción que se llevará a cabo en respuesta a eventos del mouse."	bloqueAccion := aBlock .! !!Boton methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/23/2024 11:38'!cambiarColor: hexacolor := Color fromHexString: hexa.! !!Boton methodsFor: 'accessing' stamp: 'Ernesto 2/8/2024 14:01'!label: unTexto|myString textWithStyle|myString := unTexto .textWithStyle := (myString asText)     addAttribute: (TextColor color: Color black)     from: 1     to: myString size. super label: textWithStyle  .self formato.! !!Boton methodsFor: 'initialization' stamp: 'Ernesto 12/10/2023 03:56'!initializesuper initialize .self formato! !!Boton methodsFor: 'initialization' stamp: 'Ernesto 2/23/2024 11:39'!formato|a "gradientFillStyle  c2"|a:= self.color := Color fromHexString: '#f5e6d3'.a extent: 50 @ 50. "ancho @ alto"a "useGradientFill;" borderWidth: 0; useRoundedCorners.a setBorderStyle: #complexRaised.a borderColor: Color black ."a fillStyle direction: 10@100.""c1:= Color cyan .c2 := Color blue.gradientFillStyle :=GradientFillStyle new.gradientFillStyle  colorRamp:(Array with: c1 with: c2).a fillStyle: gradientFillStyle . "! !!Boton methodsFor: 'event handling' stamp: 'Ernesto 2/4/2024 21:31'!mouseUp: unEvento"Este metodo se activa al ocurrir un evento, como un clic sobre el ratón y su posterior liberación. Dado que mouseAction retiene un bloque, se le envía el mensaje value para ejecutar las acciones especificadas dentro del bloque."bloqueAccion value.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Boton class	instanceVariableNames: ''!!Boton class methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/8/2024 12:07'!crearBoton: nombre|boton|boton:= self new.boton initialize.boton label: nombre.^boton! !!Boton class methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/4/2024 21:06'!crearBoton|boton|boton:= self new.boton initialize.^boton! !RubTextFieldMorph subclass: #Input	instanceVariableNames: ''	classVariableNames: ''	package: 'TPO-Visual'!!Input methodsFor: 'initialization' stamp: 'Ernesto 2/9/2024 19:04'!initializesuper initialize .self extent: 200 @ 100.self borderWidth: 2.self borderColor: Color white.! !!Input methodsFor: 'accessing' stamp: 'Ernesto 2/9/2024 19:03'!textoSugerencia: textoself ghostText: texto.! !!Input methodsFor: 'accessing' stamp: 'Ernesto 2/9/2024 10:51'!devolverString"devuelve el contenido del campo de texto como un String"	^self text asString .! !!Input methodsFor: 'accessing' stamp: 'Ernesto 2/9/2024 10:55'!isEmpty^self text isEmpty! !!Input methodsFor: 'accessing' stamp: 'Ernesto 2/9/2024 11:50'!isNotEmpty    ^self text isNotEmpty .! !!Input methodsFor: 'accessing' stamp: 'Ernesto 2/9/2024 10:53'!devolverNumero"devuelve el contenido del campo de texto como un String"	^self text asNumber .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Input class	instanceVariableNames: ''!!Input class methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/8/2024 18:51'!crearInput|input|input := self new.input initialize.^input ! !!Input class methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/9/2024 11:16'!crearInputCon: text|input|input := self new.input initialize.input textoSugerencia: text.^input ! !PopupChoiceOrRequestDialogWindow subclass: #PopUp	instanceVariableNames: 'botonOk'	classVariableNames: ''	package: 'TPO-Visual'!!PopUp methodsFor: 'initialization' stamp: 'Ernesto 2/9/2024 18:40'!initializesuper initialize .self ponerBoton .self addMorph:botonOk.self extent:300@50.botonOk position: self center - (botonOk extent/2) + (0 @ 10).borderWidth := 3.borderColor := Color red.botonOk mouseAction: [self cerrar]! !!PopUp methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/9/2024 18:20'!ponerBoton|colorBoton|colorBoton:=Color fromHexString: #ACB1B2.botonOk := Boton crearBoton: 'OK'.botonOk extent: 40@30.botonOk borderColor: Color white .botonOk borderWidth: 2.botonOk color: colorBoton .! !!PopUp methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/9/2024 13:13'!cerrarself delete.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PopUp class	instanceVariableNames: ''!!PopUp class methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/9/2024 18:41'!crearPopUp|popup|popup := self new.popup initialize.^popup .! !!PopUp class methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/9/2024 13:12'!crearPopUpConMensaje: unMensaje|popup|popup := self new.popup initialize.popup title: unMensaje .^popup .! !BorderedMorph subclass: #Ventana	instanceVariableNames: 'botonCerrar botonVolver empresa'	classVariableNames: ''	package: 'TPO-Visual'!!Ventana methodsFor: 'initialization' stamp: 'Ernesto 2/6/2024 07:54'!setEmpresa: nEmpresaempresa := nEmpresa .! !!Ventana methodsFor: 'initialization' stamp: 'Ernesto 2/8/2024 18:18'!initializesuper initialize.self position: 50@50.self extent: 900@599.self fondo ."Boton cerrar"botonCerrar := Boton crearBoton .botonCerrar label: 'Exit'."×"self addMorph: botonCerrar .botonCerrar position: self position+(850@0).botonCerrar mouseAction: [self cerrar]."Boton para volver a la ventana anterior"botonVolver  := Boton crearBoton .botonVolver label: 'Back'."←"botonVolver position: self position+(-1@0).self addMorph: botonVolver  .self openCenteredInWorld .! !!Ventana methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/4/2024 21:00'!cerrarself delete.! !!Ventana methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/8/2024 18:17'!agregarTitulo: unTitulo"Se utiliza para poner un encabezado de la seccion en la que se encuentra"	|titulo|	titulo := StringMorph new.	titulo contents: unTitulo  ;font: (LogicalFont familyName: StandardFonts defaultFont familyName pointSize: 30).	self addMorphCentered: titulo .	titulo top: self top+10.! !!Ventana methodsFor: 'private' stamp: 'Ernesto 2/8/2024 18:17'!fondo"C:\Users\ernes\OneDrive\Desktop\background.png""C:\Users\ernes\OneDrive\Desktop\Images\clientes.png"| img background |img := (Form fromFileNamed: 'C:\Users\ernes\OneDrive\Desktop\background.png').background := img scaledToSize: self extent.background := background asMorph.background position: self position.self addMorph: background.! !!Ventana methodsFor: 'private' stamp: 'Ernesto 2/8/2024 18:16'!fondo: url"C:\Users\ernes\OneDrive\Desktop\background.png""C:\Users\ernes\OneDrive\Desktop\Images\clientes.png"| img background |img := (Form fromFileNamed: url).background := img scaledToSize: self extent.background := background asMorph.background position: self position.self addMorph: background." no se usael fondo se superpone con los botones o queda al fondo de todo"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Ventana class	instanceVariableNames: ''!!Ventana class methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/4/2024 21:07'!crearVentana|ventana|ventana := self new.ventana initialize.^ventana ! !!Ventana class methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/6/2024 07:54'!crearVentanaConEmpresa: empresa|ventana|ventana := self new.ventana initialize.ventana setEmpresa: empresa .^ventana! !Ventana subclass: #VentanaAgregarViaje	instanceVariableNames: ''	classVariableNames: ''	package: 'TPO-Visual'!!VentanaAgregarViaje methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/19/2024 14:31'!verificarFechaCon: campoDia mes: campoMes año: campoAño"si los campos fueron llenados correctamente, se devuelve una fecha con eso, sino devuelve nil"	| fecha |	campoDia isNotEmpty & campoMes isNotEmpty & campoAño isNotEmpty		ifTrue: [			"verifico que la fecha sea un dia valido"			campoDia devolverString size = 2			& (campoDia devolverString size = 2)			& (campoAño devolverString size = 4) ifTrue: [ 				"creo la fecha AAAA-MM-DD"				fecha := (campoAño devolverString ,'-', campoMes devolverString,'-', campoDia devolverString ) asDate.				 ]			 ].		^fecha! !!VentanaAgregarViaje methodsFor: 'initialization' stamp: 'Ernesto 2/22/2024 11:13'!initialize	| campoNombre campoCosto campoImpuestos campoPersonas botonCrearViaje seleccion seleccionArea|	super initialize.	self agregarTitulo: 'AGREGAR VIAJE'.	botonVolver mouseAction: [		VentanaViajes crearVentanaConEmpresa: empresa.		self cerrar ].	campoNombre := Input crearInputCon: 'Ingrese el nombre del viaje'.	botonCrearViaje := Boton crearBoton: 'Crear Viaje'.	campoNombre position: 1000 @ 200.	campoCosto := Input crearInputCon: 'Costo por persona'.	campoImpuestos := Input crearInputCon: 'Costo impuesto'.	campoPersonas := Input crearInputCon: 'Cantidad maxima de personas'.	campoCosto position: campoNombre position + (0 @ 75).	campoImpuestos position: campoCosto position + (0 @ 75).	campoPersonas position: campoImpuestos position + (0 @ 75).	seleccion := CheckboxButtonMorph new.	seleccionArea := Input crearInputCon: 'Viaje Organizado?'.	seleccionArea		extent: 200 @ 25;		position: campoPersonas position + (0 @ 75);		disable.	seleccion position: seleccionArea position + (115 @ 6).	botonCrearViaje		extent: 120 @ 50;		position: 800 @ 300.	self		addMorph: campoCosto;		addMorph: campoImpuestos;		addMorph: campoPersonas;		addMorph: seleccionArea;		addMorph: seleccion;		addMorph: botonCrearViaje;		addMorph: campoNombre.			botonCrearViaje mouseAction: [|mensajeVacio  viaje  mensajeViaje etapas|		mensajeViaje :=PopUp crearPopUpConMensaje: 'El viaje fue creado correctamente'.		mensajeViaje borderColor: Color green; position: botonCrearViaje position +(0@75).		(campoNombre isNotEmpty & campoCosto isNotEmpty & campoImpuestos isNotEmpty & campoPersonas isNotEmpty) 		ifTrue: [  		botonCrearViaje delete.		campoNombre delete.		campoCosto delete.		campoImpuestos delete.		campoPersonas delete.		seleccion delete.		seleccionArea delete.		seleccion selected			ifTrue: [ 				etapas :=OrderedCollection new.				viaje := Organizado crear: campoNombre devolverString  etapas: etapas imp: campoImpuestos devolverNumero  costo: campoCosto devolverNumero  cantPersonas: campoPersonas devolverNumero.				empresa agregarViaje: viaje.				self addMorph: mensajeViaje .								 ]			ifFalse: [ 				"Es viaje Especial"				| campoDia campoMes campoAño campoCiudad fecha fechaVuelta mensajeFecha botonCrear|				botonCrear := Boton crearBoton: 'Crear'.				campoCiudad := Input crearInputCon: 'Ingrese la ciudad de destino'.				campoDia := Input crearInputCon: 'DD'.				campoDia extent: 50 @ 30.				campoMes := Input crearInputCon: 'MM'.				campoMes extent: 50 @ 30.				campoAño := Input crearInputCon: 'AAAA'.				campoAño extent: 50 @ 30.								campoCiudad position: 1000 @ 300.				campoDia position: campoCiudad position+(0@75).				campoMes position: campoDia position +(75@0).				campoAño  position: campoMes position + (75@0).				botonCrear position: campoDia position+(75@50).				self addMorph: campoCiudad; addMorph:campoDia; addMorph: campoMes; addMorph: campoAño; addMorph: botonCrear .								botonCrear mouseAction: [ 					botonCrearViaje delete. 								fecha:= self verificarFechaCon: campoDia mes: campoMes año: campoAño.				fecha 				ifNotNil: [ 					fechaVuelta := fecha addDays:7. 					viaje := Especial crear: campoNombre devolverString f_salida: fecha ciudad: campoCiudad devolverString  f_vuelta: fechaVuelta  imp: campoImpuestos devolverNumero  costo: campoCosto devolverNumero  cantPersonas: campoPersonas devolverNumero .					empresa agregarViaje: viaje.					self addMorph: mensajeViaje .					] 				ifNil: [ 					mensajeFecha :=PopUp crearPopUpConMensaje: 'Ingrese una fecha valida'.					mensajeFecha position: botonCrearViaje position+(0@75).					self addMorph: mensajeFecha 					 ]				]."fin mouseAction crear"								] "fin ifFalse (crear un viaje Especial)"			] 		ifFalse: [ 			mensajeVacio := PopUp crearPopUpConMensaje: 'Rellene todos los campos (obligatorio)'.			mensajeVacio position: botonCrearViaje position+(0@75).			self addMorph: mensajeVacio .			 ].				]! !Ventana subclass: #VentanaClientes	instanceVariableNames: 'campoDNI campoApellido campoCiudad campoMail campoTelefono campoPref'	classVariableNames: ''	package: 'TPO-Visual'!!VentanaClientes methodsFor: 'initialization' stamp: 'Ernesto 2/19/2024 15:49'!initialize |botonRegistrar mensajeResultado |    "Inicialización de la ventana de registro de cliente"    super initialize.    self agregarTitulo: 'REGISTRAR CLIENTE'.    botonVolver mouseAction: [ VentanaPrincipal crearVentanaConEmpresa: empresa. self cerrar ]."Creo el boton para registrar al cliente"    botonRegistrar := Boton crearBoton: 'Registrar Cliente'.    botonRegistrar position: 800@300.	 botonRegistrar extent:120@50.    self addMorph: botonRegistrar.  "mensajeResultado es la ventana emergente que te dice si el cliente se registro con exito o no"mensajeResultado := PopUp crearPopUp  .    botonRegistrar mouseAction: [        (self registrarUsuario)            ifTrue: [									mensajeResultado title: 'Cliente registrado con exito.'.					mensajeResultado borderColor: Color green.             ]            ifFalse: [					mensajeResultado title:  'Ocurrio un error, llene todos los campos.'.                          ].self addMorph: mensajeResultado.mensajeResultado position: botonRegistrar  position+(0@75).   ]."Creo todos los cuadros de texto y los posiciono"	campoDNI  := Input  crearInputCon: 'Ingrese su DNI'.	campoApellido  := Input  crearInputCon: 'Ingrese el apellido'.	campoCiudad  := Input  crearInputCon:'Ingrese su ciudad' .		campoMail := Input  crearInputCon:'Ingrese su mail' .		campoTelefono := Input  crearInputCon:'Ingrese su telefono' .		campoPref   := Input  crearInputCon: 'Ingrese sus preferencias de viaje'.	campoDNI  position: 1000@200.	campoApellido  position: campoDNI   position+(0@(75)).	campoCiudad  position: campoApellido   position +(0@(75)).	campoMail  position: campoCiudad  position +(0@(75)).	campoTelefono   position: campoMail   position +(0@(75)).	campoPref position: campoTelefono    position +(0@(75)).	self addMorph: campoApellido  .	self addMorph: campoDNI .	self addMorph: campoCiudad  .	self addMorph: campoMail  .	self addMorph: campoTelefono   .	self addMorph: campoPref   .! !!VentanaClientes methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/14/2024 13:33'!registrarUsuario    | nuevoCliente operacion |   operacion :=  	campoDNI isNotEmpty &              	 	campoApellido isNotEmpty &                   	campoCiudad isNotEmpty &                  	campoMail isNotEmpty &                  	campoTelefono isNotEmpty &					  	campoPref  isNotEmpty.operacion ifTrue: [ nuevoCliente := Cliente crear: campoDNI devolverString  ape: campoApellido devolverString city: campoCiudad devolverString correo: campoMail devolverString tel: campoTelefono devolverString pref: campoPref devolverString  ].empresa agregarCliente: nuevoCliente .    ^ operacion.! !Ventana subclass: #VentanaContratos	instanceVariableNames: ''	classVariableNames: ''	package: 'TPO-Visual'!!VentanaContratos methodsFor: 'initialization' stamp: 'Ernesto 2/19/2024 14:38'!initialize|botonGenerar botonCuotas botonModificar|	super initialize .	self agregarTitulo:  'CONTRATOS'.	botonVolver mouseAction: [VentanaPrincipal crearVentanaConEmpresa: empresa.self cerrar].		botonGenerar  := Boton crearBoton: 'Crear Contrato'.	botonGenerar  position: self position + (400 @ 200).	botonGenerar extent:120@50.	self addMorph: botonGenerar  .	botonGenerar  mouseAction: [VentanaCrearContrato crearVentanaConEmpresa: empresa .self cerrar ].		botonCuotas :=  Boton crearBoton:  'Pagar Cuotas'.	botonCuotas position: botonGenerar  position + (0 @ 100).	botonCuotas extent:120@50.	self addMorph: botonCuotas .	botonCuotas mouseAction: [ VentanaCuotas crearVentanaConEmpresa: empresa.self cerrar  ].		botonModificar  :=  Boton crearBoton:  'Modificar Contratos'.	botonModificar  position: botonCuotas  position + (0 @ 100).	botonModificar  extent:120@50.	self addMorph: botonModificar  .	botonModificar  mouseAction: [ VentanaModificarContratos  crearVentanaConEmpresa: empresa.self cerrar  ].! !Ventana subclass: #VentanaCrearContrato	instanceVariableNames: ''	classVariableNames: ''	package: 'TPO-Visual'!!VentanaCrearContrato methodsFor: 'initialization' stamp: 'Ernesto 2/22/2024 11:43'!initialize|campoViaje campoDNI campoPersonas campoDia campoMes campoAño fecha seleccion seleccionArea botonBuscar botonCrear mensajeDni mensajeResultado mensajeFecha|	super initialize.	self agregarTitulo: 'CREAR NUEVO CONTRATO'.	botonVolver mouseAction: [VentanaContratos crearVentanaConEmpresa: empresa.self cerrar].botonBuscar  := Boton crearBoton: 'Buscar Cliente'.botonBuscar  position: 800@300; extent:120@50.self addMorph: botonBuscar  .campoDNI := Input crearInputCon:'Ingrese el DNI del Cliente'.campoDNI extent: 200@30;position: 1000@310.self addMorph: campoDNI .botonBuscar mouseAction: [ 	((campoDNI isNotEmpty) & (self verifCliente: (campoDNI) devolverString )) 	"si encuentra cliente con ese DNI"	ifTrue: [ 		|coleccion f1 f2|		f1:= '1111-02-20' asDate.		f2 := '2222-12-12' asDate.		coleccion := empresa mostrarInfoViajes: f1 y: f2.		self mostrarTabla: coleccion.			botonBuscar delete.			botonCrear := Boton crearBoton:'Crear Contrato'.			botonCrear extent:120@50; position: 800@300.			campoViaje  :=Input crearInputCon:'Ingrese el Nombre del Viaje'.			campoViaje  extent: 200@30.			campoPersonas := Input crearInputCon: 'Ingrese cantidad de Personas'.			campoPersonas  extent: 200@30.			campoDia  := Input crearInputCon: 'DD'.			campoDia  extent: 50@30.			campoMes  := Input crearInputCon: 'MM'.			campoMes   extent: 50@30.			campoAño   := Input crearInputCon: 'AAAA'.			campoAño   extent: 50@30.					self addMorph: campoViaje; addMorph: campoPersonas; addMorph: campoDia; addMorph: campoMes ; addMorph: campoAño; addMorph: botonCrear .					campoDNI delete.			campoViaje position: 1000@200.			campoPersonas position: campoViaje position + (0@75).			campoDia position: campoPersonas position + (0@75).			campoMes position: campoDia position +(75@0).			campoAño  position: campoMes position + (75@0).					seleccion   := CheckboxButtonMorph  new. 			seleccionArea := Input  crearInputCon: 'Contrato Flexible?'.			seleccionArea extent: 200@25; position: campoDia position + (0@75); disable.			seleccion position: seleccionArea  position+(115@6).					self addMorph: seleccionArea; addMorph: seleccion.			botonCrear mouseAction: [ 				"verifico que la fecha sea valida, si lo es devuelve una fecha"				fecha := self verificarFechaCon: campoDia mes: campoMes año: campoAño.								fecha ifNotNil: [  					mensajeResultado := PopUp crearPopUp.					(seleccion selected) 					"creo contrato flexible"					ifTrue: [						(empresa crearContratoFlexible: campoDNI devolverString viaje: campoViaje devolverString  cant: campoPersonas devolverNumero  f: fecha)ifTrue: [ mensajeResultado title: 'Contrato creado satisfactoriamente'; borderColor: Color green. ] ifFalse:[mensajeResultado title: 'Contrato no creado' ].												] 					"creo contrato normal"					ifFalse: [						(empresa crearContrato: campoDNI devolverString viaje: campoViaje devolverString  cant: campoPersonas devolverNumero  f: fecha)ifTrue: [ mensajeResultado title: 'Contrato creado satisfactoriamente'; borderColor: Color green. ] ifFalse:[mensajeResultado title: 'Contrato no creado' ]						  						].										self addMorph: mensajeResultado.					mensajeResultado position: botonCrear  position+(0@75).					] 						ifNil:[ 							mensajeFecha :=PopUp crearPopUpConMensaje: 'Ingrese una fecha valida'.							mensajeFecha position: botonCrear position+(0@75).							self addMorph: mensajeFecha .							]  "fin de fecha nula"													]"mouseAction de crear"			] 	"si no encuentra cliente con ese DNI"	ifFalse: [ 		mensajeDni := PopUp crearPopUpConMensaje: 'No se encontro ningun cliente con ese DNI'  .		self addMorph: mensajeDni.		mensajeDni  position: botonBuscar position+(0@75) 		]	 ]! !!VentanaCrearContrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/14/2024 12:53'!verifCliente: dni(empresa verifCliente: dni)ifNil: [^false ] ifNotNil: [ ^ true ].! !!VentanaCrearContrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/18/2024 14:31'!obtenerViaje: nombreViaje(empresa obtenerViaje:  nombreViaje)ifNil: [^false ] ifNotNil: [ ^ true ].! !!VentanaCrearContrato methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/15/2024 12:00'!verificarFechaCon: campoDia mes: campoMes año: campoAño"si los campos fueron llenados correctamente, se devuelve una fecha con eso, sino devuelve nil"	| fecha |	campoDia isNotEmpty & campoMes isNotEmpty & campoAño isNotEmpty		ifTrue: [			"verifico que la fecha sea un dia valido"			campoDia devolverString size = 2			& (campoDia devolverString size = 2)			& (campoAño devolverString size = 4) ifTrue: [ 				"creo la fecha AAAA-MM-DD"				fecha := (campoAño devolverString ,'-', campoMes devolverString,'-', campoDia devolverString ) asDate.				 ]			 ].		^fecha! !!VentanaCrearContrato methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/23/2024 11:32'!mostrarTabla: coleccion    | objetoMorph  morph borderM c1 text|	text := TextMorph new.	text contents: 'Viajes de la Empresa: '.	borderM := BorderedMorph new.	c1:= Color fromHexString: '#FA8F79'.	borderM color: c1.	borderM extent: 130@50;borderWidth: 0; useRoundedCorners;setBorderStyle: #complexRaised;borderColor: Color black .	 morph:= RubPluggableTextMorph new.    coleccion do: [ :viaje |         objetoMorph := viaje mostrarInfo.        morph setText: (morph getText, objetoMorph, String cr) ].morph extent: 500@200.morph position: 550@480.text color: Color black;position: (557@445).borderM position: morph position +(0 @ -50).borderM addMorph: text.	self addMorph: morph; addMorph: borderM .! !Ventana subclass: #VentanaCuotas	instanceVariableNames: ''	classVariableNames: ''	package: 'TPO-Visual'!!VentanaCuotas methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/18/2024 12:00'!mostrarTabla: coleccion    | objetoMorph  morph|	 morph:= RubPluggableTextMorph new.    coleccion do: [ :objeto |         objetoMorph := objeto infoContrato.        morph setText: (morph getText, objetoMorph, String cr) ].morph extent: 500@200.morph position: 350@380.	self addMorph: morph .! !!VentanaCuotas methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/16/2024 22:53'!verifCliente: dni(empresa verifCliente: dni)ifNil: [^false ] ifNotNil: [ ^ true ].! !!VentanaCuotas methodsFor: 'initialization' stamp: 'Ernesto 2/23/2024 11:37'!initialize|campoDNI campoCuotas botonCuotas campoContrato botonVerContratos mensajeDni mensajeContrato valor mensajeValor|	super initialize .	self agregarTitulo:  'PAGAR CUOTAS'.	botonVolver mouseAction: [VentanaContratos crearVentanaConEmpresa: empresa.self cerrar].	campoDNI := Input crearInputCon: 'Ingrese el DNI'.campoDNI extent: 200@30;position: 350@310.botonVerContratos := Boton crearBoton: 'Buscar Contratos'.botonVerContratos cambiarColor: 'FA8F79'.botonVerContratos position: campoDNI position + (250@0) - (0@10); extent:120@50.self addMorph: botonVerContratos ; addMorph: campoDNI .botonVerContratos mouseAction: [ 	((campoDNI isNotEmpty) & (self verifCliente: (campoDNI) devolverString )) 	ifTrue: [ | contratosDelCliente |                contratosDelCliente := empresa mostrarContratos: campoDNI devolverString.					(contratosDelCliente isNotEmpty)					 ifTrue: [ 						self mostrarTabla: contratosDelCliente .						botonCuotas := Boton crearBoton: 'Pagar'.						campoContrato  := Input crearInputCon: 'ingrese el nro de contrato'.						campoContrato extent: 200@30;position: 1000@310.						campoCuotas  := Input crearInputCon: 'Ingrese la cantidad de cuotas'.						campoCuotas  extent: 200@30; position: campoContrato position + (0@75).						botonCuotas position: campoCuotas position + (50@75); extent:120@50.						self addMorph: campoContrato; addMorph: campoCuotas; addMorph: botonCuotas .						botonCuotas mouseAction: [ 							(campoContrato isNotEmpty & campoCuotas isNotEmpty )							ifTrue: [ 								valor:=empresa pagarCuotas: campoContrato devolverNumero  cant: campoCuotas devolverNumero.								mensajeValor  := PopUp crearPopUpConMensaje: 'El valor total a pagar es: ',valor asString  . 						self addMorph: mensajeValor .						mensajeValor position: botonCuotas position + (0@75)								 ] 							ifFalse: [ mensajeContrato  := PopUp crearPopUpConMensaje: 'Revise los campos'  . 						self addMorph: mensajeContrato.						mensajeContrato position: botonCuotas position + (-120@75)]								 ]						] 					 ifFalse: [						mensajeContrato  := PopUp crearPopUpConMensaje: 'El cliente no tiene ningun contrato'  . 						self addMorph: mensajeContrato.						mensajeContrato position: botonVerContratos position + (0@75)].				] 	ifFalse: [		mensajeDni := PopUp crearPopUpConMensaje: 'No se encontro ningun cliente con ese DNI'  .		self addMorph: mensajeDni.		mensajeDni  position: botonVerContratos  position+(0@75)]	  ]! !Ventana subclass: #VentanaModificarContratos	instanceVariableNames: ''	classVariableNames: ''	package: 'TPO-Visual'!!VentanaModificarContratos methodsFor: 'initialization' stamp: 'Ernesto 2/21/2024 06:23'!initialize|campoDNI botonReprogramar botonCancelar botonAgregarExcursion campoContrato botonVerContratos mensajeDni mensajeContrato mensajeExcursion mensajeReprogramar mensajeCancelar campoNombreExcursion campoPersonas|	super initialize .	self agregarTitulo:  'MODIFICAR CONTRATOS'.	botonVolver mouseAction: [VentanaContratos crearVentanaConEmpresa: empresa.self cerrar].		campoDNI := Input crearInputCon: 'Ingrese el DNI'.campoDNI extent: 200@30;position: 350@310.botonVerContratos := Boton crearBoton: 'Buscar Contratos'.botonVerContratos position: campoDNI position + (250@0) - (0@10); extent:120@50.self addMorph: botonVerContratos ; addMorph: campoDNI .botonVerContratos mouseAction: [ ((campoDNI isNotEmpty) & (self verifCliente: (campoDNI) devolverString )) 	ifTrue: [ | contratosDelCliente campoDia campoMes campoAño |                contratosDelCliente := empresa mostrarContratos: campoDNI devolverString.					(contratosDelCliente isNotEmpty) 					ifTrue: [						self mostrarTabla: contratosDelCliente .  						botonVerContratos delete.						campoDNI delete.						botonReprogramar := Boton crearBoton: 'Reprogramar Contrato'.						botonCancelar := Boton crearBoton: 'Cancelar Contrato'.						botonAgregarExcursion := Boton crearBoton: 'Agregar Excursion'.						campoContrato := Input crearInputCon: 'Ingrese el nro de contrato'.						campoNombreExcursion := Input crearInputCon: 'Ingrese el nombre de la excursion'.						campoPersonas := Input crearInputCon: 'Cant'.						campoDia  := Input crearInputCon: 'DD'.						campoDia  extent: 50@30.						campoMes  := Input crearInputCon: 'MM'.						campoMes   extent: 50@30.						campoAño   := Input crearInputCon: 'AAAA'.						campoAño   extent: 50@30.												campoContrato position: 670@275.						campoNombreExcursion position: campoContrato position + (0@50).						campoPersonas position: campoNombreExcursion position + (250@0); extent: 50@30.						campoDia position: campoNombreExcursion  position + (0@50).						campoMes position: campoDia position +(75@0).						campoAño  position: campoMes position + (75@0).						botonReprogramar position: 600@425;extent:130@50;helpText: 'Para reprogramar se utiliza el nro de contrato y la fecha'. 						botonCancelar position: botonReprogramar position + (140@0);extent:120@50; helpText: 'Para cancelar solo se utiliza el nro de contrato'.						botonAgregarExcursion position: botonCancelar position + (130@0);extent:120@50; helpText: 'Para agregar una excursion se utiliza el nro de contrato, el nombre de la excursion y la cantidad de personas'.												self addMorph: campoContrato; addMorph: campoNombreExcursion; addMorph: campoDia; addMorph: campoMes; addMorph: campoAño; addMorph: botonReprogramar; addMorph: botonCancelar; addMorph: botonAgregarExcursion; addMorph: campoPersonas  .						botonReprogramar mouseAction: [ 							|fecha pagar|							mensajeReprogramar := PopUp crearPopUp . 								mensajeReprogramar position: botonCancelar  position + (-50@100).													fecha := self verificarFechaCon: campoDia mes: campoMes año: campoAño.							(campoContrato isNotEmpty & fecha isNotNil ) ifTrue: [ 								(empresa reprogramacionContrato: campoContrato devolverNumero fecha: fecha) 								ifTrue: [ 									pagar := empresa precioPlus:  campoContrato devolverNumero.									mensajeReprogramar borderColor: Color green; title: 'Se pudo reprogramar, precio a pagar: ', pagar asString. ] 								ifFalse: [ mensajeReprogramar title: 'No se pudo reprogramar para esa fecha o el contrato no es flexible';extent: mensajeReprogramar extent + (100@0) ].																								]							ifFalse: [ 								mensajeReprogramar title: 'La fecha esta mal o el nro de contrato es incorrecto' ].							self addMorph: mensajeReprogramar .							].						botonCancelar mouseAction: [  														mensajeCancelar := PopUp crearPopUp.							mensajeCancelar position: botonCancelar  position + (-50@100).							(campoContrato isNotEmpty) 							ifTrue: [ 								|valor|								 valor := empresa cancelacionContrato: campoContrato devolverNumero .								mensajeCancelar title: 'Se cancelo su contrato, se le devolveran: $', valor asString; borderColor: Color green.																] 							ifFalse: [ mensajeCancelar title: 'Nro de contrato incorrecto'].							self addMorph: mensajeCancelar .							].						botonAgregarExcursion mouseAction: [  							mensajeExcursion := PopUp crearPopUp .							mensajeExcursion position: botonReprogramar   position + (-75@100).							(campoContrato isNotEmpty & campoNombreExcursion isNotEmpty & campoPersonas isNotEmpty )							ifTrue: [  								" nroContrato excursion: nombreExcursion personas: cant"								(empresa agregarExcursionContrato: campoContrato devolverNumero  excursion: campoNombreExcursion devolverString  personas: campoPersonas devolverNumero = -1) 								ifTrue: [  									mensajeExcursion title: 'Se agrego la excursion'; borderColor: Color green.									] 								ifFalse: [  									mensajeExcursion title: 'No se agrego la excursion'									]								] 							ifFalse:  [ mensajeExcursion title: 'No se encontro esa excursion, el nro contrato es incorrecto o no ingreso la cantidad de personas'; extent: mensajeExcursion extent+(100@0) ].							self addMorph: mensajeExcursion .							].													] 					ifFalse: [ 						mensajeContrato  := PopUp crearPopUpConMensaje: 'El cliente no tiene ningun contrato'  . 						self addMorph: mensajeContrato.						mensajeContrato position: botonVerContratos position + (0@75) 						].				] 	ifFalse: [		mensajeDni := PopUp crearPopUpConMensaje: 'No se encontro ningun cliente con ese DNI'  .		self addMorph: mensajeDni.		mensajeDni  position: botonVerContratos  position+(0@75) ] 	]! !!VentanaModificarContratos methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/19/2024 07:11'!verificarFechaCon: campoDia mes: campoMes año: campoAño"si los campos fueron llenados correctamente, se devuelve una fecha con eso, sino devuelve nil"	| fecha |	campoDia isNotEmpty & campoMes isNotEmpty & campoAño isNotEmpty		ifTrue: [			"verifico que la fecha sea un dia valido"			campoDia devolverString size = 2			& (campoDia devolverString size = 2)			& (campoAño devolverString size = 4) ifTrue: [ 				"creo la fecha AAAA-MM-DD"				fecha := (campoAño devolverString ,'-', campoMes devolverString,'-', campoDia devolverString ) asDate.				 ]			 ].		^fecha! !!VentanaModificarContratos methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/18/2024 13:49'!mostrarTabla: coleccion    | objetoMorph  morph|	 morph:= RubPluggableTextMorph new.    coleccion do: [ :objeto |         objetoMorph := objeto infoContrato.        morph setText: (morph getText, objetoMorph, String cr) ].morph extent: 500@200.morph position: 550@480.	self addMorph: morph .! !!VentanaModificarContratos methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/18/2024 13:27'!verifCliente: dni(empresa verifCliente: dni)ifNil: [^false ] ifNotNil: [ ^ true ].! !Ventana subclass: #VentanaModificarViaje	instanceVariableNames: ''	classVariableNames: ''	package: 'TPO-Visual'!!VentanaModificarViaje methodsFor: 'initialization' stamp: 'Ernesto 2/23/2024 13:02'!initialize 	| botonBuscar botonExcursion botonEtapa botonJornada botonFecha campoDia campoMes campoAño campoNombre viaje|	"se debe agregar Jornadas si es Org y se debe agregar excursiones si es  org y etapas"	super initialize.	self agregarTitulo: 'MODIFICAR VIAJE'.botonVolver  mouseAction: [ VentanaViajes crearVentanaConEmpresa: empresa.self cerrar].campoNombre := Input crearInputCon: 'Ingrese el nombre del viaje'.campoNombre position: 670@275.botonBuscar := Boton crearBoton: 'Buscar viaje'.botonBuscar position: 700@325;extent:130@50.self addMorph: campoNombre; addMorph: botonBuscar .botonBuscar mouseAction: [  	|mensajeNombre|	mensajeNombre := PopUp crearPopUp .	mensajeNombre position: botonBuscar position +(0@50).	(campoNombre isNotEmpty) 	ifTrue: [  		viaje := empresa obtenerViaje: campoNombre devolverString.		viaje 		ifNotNil: [ 			campoNombre delete.			botonBuscar delete.			 			botonFecha:= Boton crearBoton: 'Cambiar Fecha'.			botonFecha extent:120@50.			campoDia  := Input crearInputCon: 'DD'.			campoDia  extent: 50@30.			campoMes  := Input crearInputCon: 'MM'.			campoMes   extent: 50@30.			campoAño   := Input crearInputCon: 'AAAA'.			campoAño   extent: 50@30.			self addMorph: campoDia; addMorph: campoMes; addMorph: campoAño.			(viaje esOrganizado )			ifTrue: [  			|campoExcursion campoPrecio campoPersonas campoNombreEtapa  campoHotel campoDuracion campoTipo |						botonExcursion := Boton crearBoton: 'Agregar Excursion'.				botonEtapa := Boton crearBoton: 'Agregar Etapa'.				botonJornada := Boton crearBoton: 'Agregar Jornada'.				campoExcursion := Input crearInputCon: 'Ingrese el nombre de la excursion'.				campoPrecio	:= Input crearInputCon: 'Ingrese el valor de la excursion'.				campoPersonas := Input crearInputCon: 'Ingrese la cantidad de personas'.				campoNombreEtapa := Input crearInputCon: 'Ingrese el nombre de la etapa'.				campoHotel := Input crearInputCon: 'Ingrese el nombre del hotel'.				campoDuracion := Input crearInputCon: 'Ingrese la cantidad de dias de duracion'.				campoTipo := Input crearInputCon: 'Ingrse el tipo de pension'.								campoDia position: 870@275.				campoMes position: campoDia position +(75@0).				campoAño  position: campoMes position + (75@0).				campoNombreEtapa position: campoDia position +(0@50).				campoHotel position: campoNombreEtapa position +(0@50).				campoTipo position: campoHotel position + (0@50).				campoDuracion  position: campoTipo position + (0@50);extent: campoDuracion extent+(15@0).				botonEtapa  position: campoDuracion  position + (-10@50);extent:120@50; helpText: 'Necesita todos los campos'.				botonJornada position: botonEtapa position + (130@0);extent:120@50; helpText: 'Solo necesita la fecha'.								campoExcursion position: 435@275.				campoPrecio position: campoExcursion position + (0@50).				campoPersonas position: campoPrecio position + (0@50).				botonExcursion position: campoPersonas position +(50@50); extent:120@50.												self addMorph: botonExcursion; addMorph: botonJornada; addMorph: botonEtapa; addMorph: campoExcursion; addMorph: campoPrecio; addMorph: campoPersonas; addMorph: campoNombreEtapa; addMorph: campoHotel; addMorph: campoTipo; addMorph: campoDuracion    .				botonExcursion mouseAction: [ 					|mensajeExcursion|					mensajeExcursion := PopUp crearPopUp .					mensajeExcursion position: botonExcursion position+(0@50).					(campoExcursion isNotEmpty & campoPrecio isNotEmpty & campoPersonas isNotEmpty )					ifTrue: [  						viaje agregarExcursion: campoExcursion devolverString  precio: campoPrecio devolverNumero  cantPer: campoPersonas devolverNumero.						mensajeExcursion title: 'Se agrego la excursion satisfactoriamente'; borderColor: Color green.						] 					ifFalse: [  						mensajeExcursion title: 'Llene todos los campos'.						].					self addMorph: mensajeExcursion .					 ].				botonJornada mouseAction: [ 					|fecha mensajeJornada|					mensajeJornada := PopUp crearPopUp .					mensajeJornada position: botonJornada position + (0@50).					fecha := self verificarFechaCon: campoDia mes: campoMes  año: campoAño. 					fecha 					ifNotNil: [  						viaje nuevaJornada: fecha.						mensajeJornada title: 'Jornada agregada.'; borderColor: Color green.						] 					ifNil: [  						mensajeJornada title: 'La fecha ingresada es incorrecta'.						].					self addMorph: mensajeJornada.					].				botonEtapa  mouseAction: [  					|mensajeEtapa fecha|					mensajeEtapa := PopUp crearPopUp.					mensajeEtapa position: botonEtapa position+(0@50).					fecha := self verificarFechaCon: campoDia mes: campoMes  año: campoAño.					(campoNombreEtapa isNotEmpty & campoHotel isNotEmpty & campoTipo isNotEmpty & campoDuracion isNotEmpty & fecha isNotNil ) 					ifTrue: [  						|etapa|						"inicializar: nActividades d_llegada: nDia elHotel: nHotel pension: nTipoPension dias: nCantDias"						etapa := Etapa crear: campoNombreEtapa devolverString  d_llegada: fecha elHotel: campoHotel devolverString  pension: campoTipo  devolverString dias: campoDuracion devolverNumero .						viaje nuevaEtapa: etapa.						mensajeEtapa title: 'Se agrego la jornada correctamente'; borderColor: Color green.						] 					ifFalse: [  						mensajeEtapa title: 'Revise los campos'.												].					self addMorph: mensajeEtapa.					]				] 			ifFalse: [ 				|botonFechaRegreso fecha| 				botonFechaRegreso := Boton crearBoton: 'Fecha de Regreso'.				botonFechaRegreso extent:120@50 .				campoDia position: 670@275.				campoMes position: campoDia position +(75@0).				campoAño  position: campoMes position + (75@0).				botonFecha position: campoDia position + (-10@50). 				botonFechaRegreso position: botonFecha  position + (130@0).				self addMorph: botonFechaRegreso; addMorph: botonFecha.								botonFecha mouseAction: [  					|mensajeFecha|					fecha := self verificarFechaCon: campoDia mes: campoMes  año: campoAño.					mensajeFecha := PopUp crearPopUp .					mensajeFecha position: botonFecha position + (0@50).										fecha ifNotNil: [  						viaje setFecha_salida: fecha.						mensajeFecha title: 'La fecha ha sido modificada exitosamente'; borderColor: Color green.						]  ifNil: [  						mensajeFecha title: 'La fecha ingresada es incorrecta'.						]. 					self addMorph: mensajeFecha .					].				botonFechaRegreso mouseAction: [  					|mensajeFecha|					fecha := self verificarFechaCon: campoDia mes: campoMes  año: campoAño.					mensajeFecha := PopUp crearPopUp .					mensajeFecha position: botonFecha position + (0@50).					fecha ifNotNil: [  						viaje setFecha_regreso:  fecha.						mensajeFecha title: 'La fecha ha sido modificada exitosamente'; borderColor: Color green.						]  ifNil: [  						mensajeFecha title: 'La fecha ingresada es incorrecta'.						]. 					self addMorph: mensajeFecha .					].								].						] 		ifNil: [  			mensajeNombre title: 'No se encontro viaje con ese nombre'.			self addMorph: mensajeNombre			].		] 	ifFalse: [ 		mensajeNombre title: 'Ingrese el nombre del viaje'.		self addMorph: mensajeNombre  ]	].! !!VentanaModificarViaje methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/21/2024 18:09'!verificarFechaCon: campoDia mes: campoMes año: campoAño"si los campos fueron llenados correctamente, se devuelve una fecha con eso, sino devuelve nil"	| fecha |	campoDia isNotEmpty & campoMes isNotEmpty & campoAño isNotEmpty		ifTrue: [			"verifico que la fecha sea un dia valido"			campoDia devolverString size = 2			& (campoDia devolverString size = 2)			& (campoAño devolverString size = 4) ifTrue: [ 				"creo la fecha AAAA-MM-DD"				fecha := (campoAño devolverString ,'-', campoMes devolverString,'-', campoDia devolverString ) asDate.				 ]			 ].		^fecha! !Ventana subclass: #VentanaPrincipal	instanceVariableNames: ''	classVariableNames: ''	package: 'TPO-Visual'!!VentanaPrincipal methodsFor: 'initialization' stamp: 'Ernesto 2/23/2024 14:53'!initialize|botClientes botViajes botContratos botonInicioDia|super initialize .self agregarTitulo: 'SISTEMA DE VIAJES'.botonVolver delete.botClientes:= Boton crearBoton: 'Registrar Cliente' .botClientes  extent:120@50.self addMorph: botClientes .botClientes position: self position + (400 @ 200). botClientes mouseAction: [	 VentanaClientes crearVentanaConEmpresa: empresa .	self cerrar .	].botContratos:= Boton crearBoton: 'Contratos' .botContratos extent:120@50.botContratos position: botClientes   position + (0 @ 100).self addMorph: botContratos .botContratos mouseAction: [ VentanaContratos crearVentanaConEmpresa: empresa .	self cerrar].botViajes := Boton crearBoton: 'Viajes' .botViajes  extent:120@50.botViajes position: botContratos  position + (0 @ 100).self addMorph: botViajes .botViajes mouseAction: [ VentanaViajes crearVentanaConEmpresa: empresa. self cerrar ].botonInicioDia := Boton crearBoton: 'Iniciar Dia'.botonInicioDia extent: 120@50;position: botonCerrar position+(-100@120).self addMorph: botonInicioDia.botonInicioDia mouseAction: [ 	empresa iniciarDia.	]! !Ventana subclass: #VentanaViajes	instanceVariableNames: ''	classVariableNames: ''	package: 'TPO-Visual'!!VentanaViajes methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/21/2024 13:46'!verificarFechaCon: campoDia mes: campoMes año: campoAño"si los campos fueron llenados correctamente, se devuelve una fecha con eso, sino devuelve nil"	| fecha |	campoDia isNotEmpty & campoMes isNotEmpty & campoAño isNotEmpty		ifTrue: [			"verifico que la fecha sea un dia valido"			campoDia devolverString size = 2			& (campoDia devolverString size = 2)			& (campoAño devolverString size = 4) ifTrue: [ 				"creo la fecha AAAA-MM-DD"				fecha := (campoAño devolverString ,'-', campoMes devolverString,'-', campoDia devolverString ) asDate.				 ]			 ].		^fecha! !!VentanaViajes methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/21/2024 14:47'!mostrarTabla: coleccion    | objetoMorph  morph|	 morph:= RubPluggableTextMorph new.    coleccion do: [ :viaje |         objetoMorph := viaje mostrarInfo.        morph setText: (morph getText, objetoMorph, String cr) ].morph extent: 500@200.morph position: 550@480.	self addMorph: morph .! !!VentanaViajes methodsFor: 'initialization' stamp: 'Ernesto 2/23/2024 14:54'!initialize 	| botonAgregar botonSacar botonModificar botonBuscar|	"se debe agregar Jornadas si es Org y se debe agregar excursiones si es  org"	super initialize.	self agregarTitulo: 'VIAJES'.botonVolver  mouseAction: [ VentanaPrincipal crearVentanaConEmpresa: empresa.self cerrar].botonAgregar := Boton crearBoton: 'Agregar Viaje'.botonAgregar extent:120@50;position: self position + (400 @ 200); mouseAction: [VentanaAgregarViaje  crearVentanaConEmpresa: empresa.self cerrar].botonSacar := Boton crearBoton: 'Eliminar viaje'.botonSacar extent:120@50;position: botonAgregar position + (0@75) .botonModificar := Boton crearBoton: 'Modificar Viaje'.botonModificar extent:120@50;position: botonSacar position + (0@75).botonBuscar := Boton crearBoton: 'Buscar Viaje'.botonBuscar extent:120@50;position: botonModificar position + (0@75). self addMorph: botonAgregar ;addMorph:botonSacar;addMorph:botonModificar;addMorph:botonBuscar.botonModificar mouseAction: [	VentanaModificarViaje crearVentanaConEmpresa: empresa.self cerrar	].botonBuscar mouseAction: [ 	|campoDia campoMes campoAño fecha diaAux mesAux añoAux fechaAux buscar mensajeBuscar|	botonAgregar delete.	botonSacar  delete.	botonModificar delete.	botonBuscar delete.		buscar := Boton crearBoton: 'Buscar'.	mensajeBuscar := PopUp crearPopUp .		campoDia := Input crearInputCon: 'DD'.	campoDia  extent: 50@30.	campoMes  := Input crearInputCon: 'MM'.	campoMes   extent: 50@30.	campoAño   := Input crearInputCon: 'AAAA'.	campoAño   extent: 50@30.	diaAux  := Input crearInputCon: 'DD'.	diaAux   extent: 50@30.	mesAux   := Input crearInputCon: 'MM'.	mesAux    extent: 50@30.	añoAux    := Input crearInputCon: 'AAAA'.	añoAux   extent: 50@30.		campoDia position: 670@275.	campoMes position: campoDia position + (75@0).	campoAño position: campoMes  position + (75@0).	diaAux  position: campoDia position + (0@50).	mesAux  position: diaAux  position + (75@0).	añoAux   position: mesAux  position + (75@0).	buscar position: mesAux position + (0@50).	mensajeBuscar position: buscar position + (100@0).	self addMorph: buscar; addMorph: campoDia; addMorph: campoMes; addMorph: campoAño; addMorph: diaAux; addMorph: mesAux; addMorph: añoAux .			buscar mouseAction: [  	fecha := self verificarFechaCon: campoDia  mes: campoMes  año: campoAño . 	fechaAux := self verificarFechaCon: diaAux  mes: mesAux  año: añoAux.	(fecha isNotNil & fechaAux isNotNil )	ifTrue: [  		|coleccion|		coleccion := empresa mostrarInfoViajes: fecha y: fechaAux.		coleccion isEmpty		ifFalse: [ 			mensajeBuscar borderColor: Color green; title: 'Se han encontrado estos viajes: '.			self mostrarTabla: coleccion ] 		ifTrue: [ mensajeBuscar title: 'No se encontraron viajes entre esas fechas' ]		] 	ifFalse: [  		mensajeBuscar title: 'Ingrese una fecha correcta '.		].	self addMorph: mensajeBuscar .	]		 ].botonSacar mouseAction: [ 	|botonBorrar mensajeViaje campoNombre viaje|	botonAgregar delete.	botonSacar  delete.	botonModificar delete.	botonBuscar delete.		campoNombre := Input crearInputCon: 'Ingrese el nombre del viaje'.	campoNombre position: 670@275.	mensajeViaje := PopUp crearPopUp .	botonBorrar := Boton crearBoton: 'Borrar'.	botonBorrar position: campoNombre position + (75@50).	self addMorph: campoNombre; addMorph: botonBorrar .	botonBorrar mouseAction: [  	(campoNombre isNotEmpty) 	ifTrue: [ 		viaje := empresa obtenerViaje: campoNombre devolverString .		viaje 		ifNotNil: [  			empresa bajaViaje: viaje .			mensajeViaje title: 'Viaje borrado y contratos dados de baja exitosamente'; position: botonBorrar position + (0@75); borderColor: Color green.			] 		ifNil: [  			mensajeViaje title: 'No se encontro un viaje con ese nombre';position: botonBorrar position + (0@75);borderColor: Color red.			]		 ] 	ifFalse: [ 		mensajeViaje title: 'Complete el campo con el nombre del viaje';position: botonBorrar position + (0@75).		 ].	self addMorph: mensajeViaje .	 ]	].! !Object subclass: #Cliente	instanceVariableNames: 'apellido dni ciudadOrigen mail telefono colContratos preferencias colContratosEfectivos'	classVariableNames: ''	package: 'TPO-Clases'!!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 02:42'!esFrecuente^false"Exactamente igual que el mensaje 'EsOrganizado'. Como no es ClienteFrecuente retorna false"! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/28/2023 03:59'!bajarContratos: unViaje|contratos rta|rta := false.contratos := colContratos select: [ :contrato | (contrato contratoTieneViaje: unViaje) & (contrato vencido not) & (contrato efectivo not) ]."Puede darse la posibilidad de que el contrato sea efectivo pero que laempresa todavia no lo haya marcado ya que verifican solo al inicio del dia. por eso el 'efectivo not'"contratos ifNotNil: [	 contratos do: [ :contrato | contrato darBaja ].	 rta := true.	].^rta"Este metodo es utilizado cuando se da de baja un viaje y hay que dar de bajalos contratos que esten vigentes para posteriormente mandar un aviso de queese viaje fue dado de baja y se cayo el contrato"! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 02:23'!cancelarContrato: unContrato"Este metodo cancela un contrato, ya hizo las verificaciones de que ese contrato existe"^unContrato cancelar ! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/28/2023 03:30'!viajaA: unViaje"este metodo es utilizado para cuando se da de baja un viaje, para dar de bajas los contratos vigentes con ese viaje"^colContratos detect: [ :contrato | contrato contratoTieneViaje: unViaje ] ifFound: [ true ] ifNone: [ false ]."este mensaje devuelve T/F si un cliente tiene al menos un 1 contrato con el viaje indicado"! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/23/2024 14:27'!generarAvisoBaja^'tiene un contrato que se ha dado de baja'"Cuando se cancela un viaje y se da de baja el contrato, se utiliza generarAvisoBaja para avisarle al Cliente"! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 13:22'!generarAviso^ 'se te va a vencer un contrato'"Cuando un contrato esta por vencer, se utiliza este metodo Se utiliza al iniciar el dia"! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 1/11/2024 22:30'!yaViajo"metodo utilizado para iniciar el dia, selecciona los contratos efectivos dentro de colContratos"|colAux cont|"si mi coleccion de contratos no esta vacia"colContratos ifNotEmpty: [ cont:=0.colAux:= colContratos select:[:contrato | contrato efectivo].colAux ifNotNil: [  	cont:= colAux size.	"los saca de la colContratos y los agrega a colContratosEfectivos"	colContratos removeAll: colAux.	colContratosEfectivos addAll: colAux ]. ]."retorna la cantidad de contratos efectivos que hubo para luego utilizar este numero enel viajerofrecuente para que sume millas por cada uno de sus contratos"^cont! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 13:53'!generarContratoFlexible: unViaje personas: cantPersonas fecha:unaFecha| contrato |contrato := ContratoFlexible  crear: unViaje  personas: cantPersonas fecha:unaFecha.colContratos add: contrato."Exactamente igual que generarContrato pero agrega un ContratoFlexible"! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 1/18/2024 11:52'!transformar| frecuente |frecuente := ViajeroFrecuente crear: dni ape: apellido city: ciudadOrigen  correo: mail tel: telefono  pref: preferencias."si es que tiene contratos, se copian esos contratos"(colContratos size + colContratosEfectivos size > 0) ifTrue: [ 		frecuente  setColContratos: colContratos .	frecuente  setColContratosEfectivos: colContratosEfectivos .  ].^frecuente"Transforma un Cliente en un Viajero-Frecuente"! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 02:37'!contratoPorVencer|elContrato rta |rta:=false.elContrato :=colContratos detect: [ :contrato | (contrato estaPagado) not  & contrato porCaducar ] ifNone:  [ nil ].elContrato  ifNotNil: [ rta := true ].^rta"Si el cliente tiene un contrato que esta por vencer y no esta pagado retortra true para asi avisarle a todos esos clientes, que tienen al menos un contrato que se esta por vencer"! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 1/16/2024 12:02'!reprogramarContrato: contrato fecha: nuevaFecha"Previamente ya verifique que es econtrato existe"^ contrato reprogramar: nuevaFecha. "reprogramarFecha retorna T/F, en caso de ser posible, lo reprograma"! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 1/18/2024 10:23'!posibleFrecuente"este mensaje es utilizado para cambiar el estado de Cliente-ViajeroFrecuente"| fechaActual año rta|fechaActual := Date today.año := fechaActual subtractDays: 365."si hay mas de 1 contrato entre las dos colecciones (o sea, no es un cliente nuevo)"(colContratos size + colContratosEfectivos size > 1)ifTrue: [  	"si hay un contrato que sea organizado y este en el ultimo año retorna true, en el resto de los casos retorna false"	colContratosEfectivos detect: [  :contrato | (contrato getViaje) esOrganizado  & (contrato getViaje) viajesEn: año y: fechaActual ] ifFound: [ rta:=true. ] ifNone: [ rta:=false].	 ]ifFalse: [ 	rta:=false ].^rta! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 13:59'!obtenerContrato: nroContrato| unContrato|unContrato := colContratos detect: [ :contrato | (contrato getNroContrato) = nroContrato] ifNone: [ nil ].^unContrato "Dado un nummero de contrato retorna el propio contrato, si es que existe, sino retorna null porque no hay un contrato con ese nroContrato"! !!Cliente methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/18/2024 10:14'!generarContrato: unViaje personas: cantPersonas fecha: unaFecha| contrato|contrato := Contrato crear: unViaje  personas: cantPersonas fecha: unaFecha.colContratos add: contrato ."Utilizado por crearContrato() de empresa para crear un contrato y agregarlo a su colContratos. El cliente ya esta previamente verificado."! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:44'!getCiudadOrigen	^ ciudadOrigen! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 12/27/2023 12:58'!setColContratosEfectivos: anObject	colContratosEfectivos := anObject! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:45'!setPreferencias: anObject	preferencias := anObject! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:45'!getTelefono	^ telefono! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:44'!setDni: anObject	dni := anObject! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:44'!getColContratos	^ colContratos! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:45'!getPreferencias	^ preferencias! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:44'!setCiudadOrigen: anObject	ciudadOrigen := anObject! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:44'!getDni	^ dni! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:45'!getMail	^ mail! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 23:42'!setApellido: anObject	apellido := anObject! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:46'!setTelefono: anObject	telefono := anObject! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:45'!setMail: anObject	mail := anObject! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:44'!setColContratos: anObject	colContratos := anObject! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 12/27/2023 12:58'!getColContratosEfectivos	^ colContratosEfectivos! !!Cliente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 23:42'!getApellido	^ apellido! !!Cliente methodsFor: 'initialization' stamp: 'Ernesto 12/10/2023 03:29'!inicializar: nDni ape: nApellido city: nCiudad correo: nMail tel: nTelefono pref: nPreferenciascolContratos := OrderedCollection new.colContratosEfectivos :=OrderedCollection  new.dni:=nDni .apellido := nApellido.ciudadOrigen := nCiudad .mail := nMail.telefono := nTelefono .preferencias := nPreferencias .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cliente class	instanceVariableNames: ''!!Cliente class methodsFor: 'as yet unclassified' stamp: 'Ernesto 7/9/2023 23:47'!crear: nDni ape: nApellido city: nCiudad correo: nMail tel: nTelefono pref: nPreferencias|unCliente|unCliente := self new.unCliente  inicializar: nDni ape: nApellido city: nCiudad correo: nMail tel: nTelefono pref: nPreferencias.^unCliente ! !Object subclass: #Contrato	instanceVariableNames: 'nroContrato fecha_contrato viaje fechaViaje cantPersonas colCuotas fecha_vto valor baja colExcursionesContratadas'	classVariableNames: 'ultimoNroContrato'	package: 'TPO-Clases'!!Contrato methodsFor: 'as yet unclassified' stamp: 'Ernesto 12/28/2023 03:30'!contratoTieneViaje: unViaje|rta|rta:=unViaje =viaje.^ rta."devuelve T/F si el contrato tiene ese viaje. Se utiliza para verificar si es posible darlo de baja"! !!Contrato methodsFor: 'as yet unclassified' stamp: 'Ernesto 12/23/2023 18:56'!sacarPersonasAJornada: unaFecha"este algotirmo es utilizado al reprogramar un viaje"| unaJornada |unaJornada := viaje obtenerJornada: unaFecha.unaJornada devolverCupos: cantPersonas .! !!Contrato methodsFor: 'as yet unclassified' stamp: 'Ernesto 12/23/2023 18:28'!getBaja^baja ! !!Contrato methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/18/2024 10:38'!esFlex^false.! !!Contrato methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/18/2024 15:52'!infoContrato|string|string := 'Nro contrato: ', nroContrato asString, ' Es flexible?: ', self esFlex asString, 'Para el viaje: ', viaje mostrarInfo.^string! !!Contrato methodsFor: 'as yet unclassified' stamp: 'Ernesto 12/23/2023 17:04'!verifParaExcursion: unaExcursion cant: cantidad| sumaPersonasConExcursion rta|rta := false.sumaPersonasConExcursion := colExcursionesContratadas inject: 0 into: [ :total :excursion | total + (excursion getPersonasContratadas ifNil: [ 0 ]) ]. "suma la cantidad total de personas que hay en las excursiones contratadas"(sumaPersonasConExcursion + cantidad < cantPersonas) ifTrue: [ 	"si la suma de todas las personas con excursion en mi contrato + la cantidad que deseoes menor a la cantidad total de personas que hay en el contrato: "	(unaExcursion excursionDisponible: cantidad) ifTrue: [ 		"verifica que la excursion este disponible para esa cantidad de personas				si es posible actualiza."		rta := true. 		]	 ].^rta! !!Contrato methodsFor: 'as yet unclassified' stamp: 'Ernesto 12/23/2023 18:56'!agregarPersonasAJornada: unaFecha"Este metodo esta separado del inicializador debido a que tambien se utiliza en caso de querer reprogramar el viaje"| unaJornada |unaJornada := viaje obtenerJornada: unaFecha.unaJornada actualizarJornada: cantPersonas .fechaViaje := unaFecha .fecha_vto :=fechaViaje subtractDays: 7.! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/21/2024 05:56'!cancelar"este metodo retorna el dinero que se debe devolver al cliente"|rta porcentaje valorTotal |valorTotal:= self valorPagado.porcentaje := self obtenerReembolso.rta:=valorTotal * porcentaje ."ademas se liberaran los cupos del viaje que se ha cancelado"self sacarPersonasAJornada: fechaViaje .^rta.! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 01:52'!crearCuotas: cant"este metodo no esta diagramado porque en si no se usa, dada una determinada cantidad de cuotas, verifica si ese contrato acepta ser pagado en dichas cuotas"| fechaActual aux rta cuota vencimiento precioCuota|rta:=false.fechaActual := Date today.(cant > 0) ifTrue: [ 	"aux guarda la fecha actual + los meses (ingresados como cant cuotas que deseo) para posteriormente ver que no se pase la fecha limite (y asi saber si es posible pagarl el viaje en esa cantidad de cuotas) "	aux:=fechaActual addMonths: cant.	(aux <= fecha_vto) ifTrue:[ 		"de ser posible, crea todas esas cuotas y las va guardando en colCuotas"		rta:=true.		vencimiento := fechaActual.		precioCuota := (valor / cant).		1 to: cant do: [:i |  	         cuota := Cuotas crear: i f: vencimiento valor:precioCuota.                        	         colCuotas add: cuota.                       vencimiento := vencimiento addDays: 30.        ].	]. ].^rta! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/24/2023 11:45'!efectivo"este mensaje lo usa la EmpresaTurismo todos los dias para verificar si un viaje es efectivo o no."|fechaActual rta  pagado|rta := false. baja ifFalse: [ 	pagado := self estaPagado .	pagado  ifTrue: [ 		fechaActual := Date today.		rta  := fechaActual > fechaViaje  .		]. ].^rta."si el contrato no es dado de baja, esta pagado y la fecha actual supera la fecha del viaje retorna True posteriormente lo quito de mi coleccion de contratos y lo agrego a una coleccion de contratos efectivos"! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/24/2023 11:43'!vencido"si el contrato no esta dado de baja, no esta pagado y la fecha actual supero la fecha de vencimiento es porque esta vencido"|fechaActual pagado rta|rta := false.baja ifFalse: [ 	pagado := self estaPagado.		pagado ifFalse:[		fechaActual := Date today.		rta := fechaActual > fecha_vto .		]. ].^rta! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/19/2024 06:41'!pagar"tomo la primer cuota que no este pagada y la pago"| unaCuota rta|unaCuota := colCuotas detect: [:cuota | cuota getPagada not ] ifNone: [nil].rta := unaCuota ifNotNil: [ unaCuota pagarCuota. ] ifNil: [ 0 ].^rta"previamente verifico que esas cuotas se pueden pagar, por ende el detect siempre devolvera una cuota impaga"! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 01:54'!agregarExcursion: nombreExcursion personas: cantP"cantP es la cantidad de personas que desea agregar excursion"|aux precio excursion |precio := false."aux es la excursion con el nombre buscado"aux := viaje obtenerExcursion: nombreExcursion .aux ifNotNil: [ "si encuentra excursion con ese nombre: "	(self verifParaExcursion: aux cant: cantP) ifTrue: [		" si es posible contratar excursion para esa cantidad de personas"			excursion := ExcursionContratada crear: aux personas: cantP. 			colExcursionesContratadas add: excursion .			precio := aux getPrecio ] 		].^precio ! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/23/2023 17:17'!valorPagado"Este metodo devuelve el valor total que se ha pagado del contrato ya sea un contrato de 1 solo pago(1 cuota) como de mas de una"|valorTotal|valorTotal :=0."valorTotal es una variable que va a ir sumando el precio  de cada una de las cuotas pagadas"colCuotas do:[:unaCuota | (unaCuota getPagada) ifTrue: [valorTotal:=valorTotal+(unaCuota getValorCuota)]. ].^valorTotal! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 8/5/2023 10:45'!darBajabaja := true.! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 21:04'!reprogramar: nuevaFecha^false."retorna false porque es una ventaja solo de los contratos flexibles"! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/18/2024 13:08'!verifCuotas: cantCuotas|rta cont|cont:=0.rta:= false."cuenta las cuotas no pagadas "colCuotas do:[ :cuota | (cuota getPagada) ifFalse: [		cont:=cont+1.]	]."si la cantidad de cuotas no pagadas es mayor o igual a la cantCuotas significa que puede pagar esa cantidad"(cont>=cantCuotas)ifTrue: [ 	rta:=true. ].^rta"no verifico que no este vencido porque ya lo hace el obtenerContrato que previamente use"! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/24/2023 12:05'!estaPagado|pagado|pagado:=false.(colCuotas isEmpty) ifTrue:[pagado:=true].^pagado"si la coleccion de cuotas esta vacia es porque esta pagado, debido a que a medida que pago las cuotas las borro de mi coleccion"! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/19/2024 07:52'!porCaducar	| caduca fechaActual aux |	caduca := false.	aux := fecha_vto subtractDays: 7.	fechaActual := Date today.	caduca := fechaActual between: aux and: fecha_vto.	^ caduca	"si faltan 7 dias o menos para la fecha de vencimiento, retorna True "! !!Contrato methodsFor: 'accessing - implementations' stamp: 'Ernesto 1/9/2024 01:15'!obtenerReembolso| porcentajeReembolso fechaActual diferenciaDias diferenciaMeses porcentaje |"dada la fecha actual (en la que se esta queriendo hacer un reembolso) "porcentajeReembolso := Dictionary new.porcentajeReembolso"debido a que no funcionan los diccionarios con rangos numericos tuve que hacer uno por uno"     at: 0 put: 0.25;	  at: 1 put: 0.25;	  at: 2 put: 0.5;	  at: 3 put: 0.5;	  at: 4 put: 0.75.fechaActual := Date today."contamos la diferencia de meses desde la fecha actual hasta la fecha del viaje"diferenciaDias := fechaViaje julianDayNumber - fechaActual julianDayNumber.diferenciaMeses := diferenciaDias // 30."obtenemos el porcentaje segun esa diferencia de meses, usando el diccionario de arriba"porcentaje := porcentajeReembolso at: (diferenciaMeses min: 4)."el 'min:4' lo que hace es que, si diferencia de meses es mayor a 4 se considera la clave '4' que es 0.75"^porcentaje ! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:47'!getCantPersonas	^ cantPersonas! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:48'!setFecha_vto: anObject	fecha_vto := anObject! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:48'!getFecha_contrato	^ fecha_contrato! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:47'!getColCuotas	^ colCuotas! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:48'!setFechaViaje: anObject	fechaViaje := anObject! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/13/2023 01:43'!getValor^valor! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 12/23/2023 17:04'!getColExcursiones^colExcursionesContratadas .! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:47'!setColCuotas: anObject	colCuotas := anObject! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 10:02'!getNroContrato	^ nroContrato ! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:47'!setCantPersonas: anObject	cantPersonas := anObject! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:49'!getViaje	^ viaje! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:48'!setFecha_contrato: anObject	fecha_contrato := anObject! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 12/23/2023 17:04'!setColExcursiones: excursiones colExcursionesContratadas := excursiones   .! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:48'!getFecha_vto	^ fecha_vto! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:49'!setViaje: anObject	viaje := anObject! !!Contrato methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:48'!getFechaViaje	^ fechaViaje! !!Contrato methodsFor: 'initialization' stamp: 'Ernesto 2/18/2024 15:41'!inicializar: elViaje personas: cantPer fecha:unaFecha|aux|nroContrato := self class getUltimoNumero.aux := nroContrato +1.self class aumentarUltimoNro .viaje := elViaje .cantPersonas := cantPer ."colCuotas := SortedCollection sortBlock: [ :cuota1 :cuota2 | cuota1 getFecha_vencimiento < cuota2 getFecha_vencimiento]."colCuotas := OrderedCollection new.colExcursionesContratadas := OrderedCollection new.fecha_contrato := Date today .valor := viaje obtenerValor.self agregarPersonasAJornada: unaFecha .self crearCuotas: 1.baja := false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Contrato class	instanceVariableNames: ''!!Contrato class methodsFor: 'as yet unclassified' stamp: 'Ernesto 12/28/2023 03:48'!crear: elViaje personas: cantPer fecha: unaFecha|unContrato|unContrato := self new.unContrato inicializar: elViaje personas: cantPer fecha:unaFecha.^unContrato .! !!Contrato class methodsFor: 'as yet unclassified' stamp: 'Ernesto 8/3/2023 19:08'!aumentarUltimoNroultimoNroContrato := ultimoNroContrato+1.! !!Contrato class methodsFor: 'as yet unclassified' stamp: 'Ernesto 7/9/2023 23:15'!inicializarNroContratoultimoNroContrato := 0.! !!Contrato class methodsFor: 'as yet unclassified' stamp: 'Ernesto 8/3/2023 18:20'!getUltimoNumero^ultimoNroContrato ! !Contrato subclass: #ContratoFlexible	instanceVariableNames: 'plus'	classVariableNames: ''	package: 'TPO-Clases'!!ContratoFlexible methodsFor: 'initialization' stamp: 'Ernesto 8/3/2023 19:07'!inicializar: elViaje personas: cantPer fecha:unaFechasuper inicializar: elViaje personas: cantPer fecha:unaFecha.plus:= valor/4.! !!ContratoFlexible methodsFor: 'accessing' stamp: 'Ernesto 7/13/2023 00:42'!getPlus^plus ! !!ContratoFlexible methodsFor: 'accessing' stamp: 'Ernesto 7/13/2023 00:43'!setPlus: anObjectplus:=anObject  ! !!ContratoFlexible methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/18/2024 10:38'!esFlex^true.! !!ContratoFlexible methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/21/2024 05:18'!reprogramar: nuevaFecha"si es posible reprogramar el viaje con la fecha indicada, retorna true"|rta|rta := viaje esReprogramable: cantPersonas  fecha: nuevaFecha   . "si el viaje es Especial, simplemente se le cambia la fecha de salida en el mensaje 'esReprogramable' en cambio si es organizado solo retorna T/F"rta ifTrue: [	viaje esOrganizado ifTrue:[ "como el 'esReprogamable' de organizado solo verifica, aca modifico esas jornadas"	"agrego las personas de este contrato a la nueva jornada y las saco de la jornada vieja"	self sacarPersonasAJornada: fechaViaje .	self agregarPersonasAJornada: nuevaFecha .	 ].	].^rta! !Object subclass: #Cuotas	instanceVariableNames: 'fecha_vto nro valorCuota pagada fechaPago'	classVariableNames: ''	package: 'TPO-Clases'!!Cuotas methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:42'!getNroCuota	^ nro! !!Cuotas methodsFor: 'accessing' stamp: 'Ernesto 7/17/2023 22:59'!getValorCuota	^ valorCuota! !!Cuotas methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:42'!setNroCuota: anObject	nro := anObject! !!Cuotas methodsFor: 'accessing' stamp: 'Ernesto 8/3/2023 10:37'!setFecha_vencimiento: anObject	fecha_vto := anObject! !!Cuotas methodsFor: 'accessing' stamp: 'Ernesto 7/28/2023 05:02'!setPagada: booleanopagada := booleano.! !!Cuotas methodsFor: 'accessing' stamp: 'Ernesto 7/19/2023 19:52'!getPagada	^ pagada! !!Cuotas methodsFor: 'accessing' stamp: 'Ernesto 8/3/2023 10:36'!getFecha_vencimiento	^ fecha_vto! !!Cuotas methodsFor: 'accessing' stamp: 'Ernesto 8/3/2023 06:22'!setFechaPago: anObject	fechaPago := anObject! !!Cuotas methodsFor: 'accessing' stamp: 'Ernesto 8/3/2023 06:22'!getFechaPago	^ fechaPago! !!Cuotas methodsFor: 'accessing' stamp: 'Ernesto 7/17/2023 22:59'!setValorCuota: anObject	valorCuota := anObject! !!Cuotas methodsFor: 'as yet unclassified'!pagarCuotafechaPago := Date today.pagada := true.^valorCuota ! !!Cuotas methodsFor: 'initialization' stamp: 'Ernesto 8/4/2023 00:25'!inicializar: nroCuota f:vto valor: precionro := nroCuota .fecha_vto := vto.valorCuota :=precio.pagada :=false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cuotas class	instanceVariableNames: ''!!Cuotas class methodsFor: 'as yet unclassified' stamp: 'Ernesto 8/4/2023 00:26'!crear: nroCuota f:vto valor: precio|unaCuota|unaCuota := self new.unaCuota inicializar: nroCuota  f:vto valor: precio.^unaCuota  ! !Object subclass: #EmpresaTurismo	instanceVariableNames: 'colClientes colViajes'	classVariableNames: ''	package: 'TPO-Clases'!!EmpresaTurismo methodsFor: 'para contratos' stamp: 'Ernesto 12/27/2023 23:02'!agregarExcursionContrato: nroContrato excursion: nombreExcursion personas: cant"En este mensaje solo verificamos que el contrato exista y que la cantidad de personas sea validapara poder hacer excursiones en ese contrato. El resto de verificaciones las hace 'agregarExcursion' de Contrato"|unCliente contrato rta|rta := -1."obtenerContrato devuelve el contrato o nil. entonces si no es nil unCliente va a ser el Cliente con dicho contrato"unCliente := colClientes detect: [ :cliente | (contrato := cliente obtenerContrato: nroContrato) notNil] ifNone: [ nil ].unCliente ifNotNil: [	"si un cliente no es nulo es porque encontro ese contrato y 'contrato' tampoco sera nulo"	 ( cant > 0 & contrato getCantPersonas > cant) ifTrue: [ 		"agregarExcursion retorna el valor de la excursion si es posible y -1 si no es posible		(ya sea porque no existe esa excursion o porque no se puede)"			rta := contrato agregarExcursion:  nombreExcursion personas: cant.				] ].^rta! !!EmpresaTurismo methodsFor: 'para contratos' stamp: 'Ernesto 1/11/2024 20:44'!efectivizacionContratocolClientes do:[:cliente | cliente yaViajo]" Metodo utilizado al iniciar el dia para verificar si el cliente viajo  Si ya lo hizo, el metodo cambia el estado del contrato"! !!EmpresaTurismo methodsFor: 'para contratos' stamp: 'Ernesto 2/18/2024 14:31'!crearContrato: dni viaje: nombreViaje cant:personas f:unaFecha"* Si el cliente no existe en mi coleccion o si el viaje no esta disponible para     * esa cantidad de personas, devuelve false.     * En caso de que sea posible, crea el contrato. Luego verifica si es necesario     * cambiar el tipo de Cliente. En caso de que sea necesario, borra la instancia     * anterior y en su lugar lo ocupa la nueva"|unCliente rta aux unViaje|rta:=false."verifCliente retorna nulo si no encuentra o retorna al Cliente con ese dni"unCliente := self verifCliente: dni.unViaje := self obtenerViaje: nombreViaje.unCliente ifNotNil: [ 	unViaje ifNotNil: [ 	"verifViaje retorna T/F si es posible ese viaje para esas personas con esa fecha"	(unViaje verifViaje: personas fecha:  unaFecha) ifTrue: [						"crea un contrato comun y lo agrega a la coleccion"		unCliente generarContrato: unViaje personas: personas fecha: unaFecha.		rta:=true.		"transformarCliente retorna nulo si no se actualizo, sino retorna al Cliente transformado (ya sea en viajeroFrecuente o en Cliente"		aux := self transformarCliente: unCliente.		aux ifNotNil: [ 			"si aux no es nulo es porque se 'transformo' al cliente. entonces borro su estado anterior y agrego al nuevo"			colClientes remove: unCliente .			colClientes add: aux.			 ]		]	 ] ].^rta! !!EmpresaTurismo methodsFor: 'para contratos' stamp: 'Ernesto 2/21/2024 05:55'!cancelacionContrato: nroContrato"devuelve el 'valor' que se le debe devolver al cliente al cancelar el contrato"| unCliente  valor contrato |valor:=0.unCliente := colClientes detect: [ :cliente | (cliente obtenerContrato: nroContrato) notNil ] ifNone: [ nil ].unCliente ifNotNil: [ 		contrato := unCliente getColContratos detect: [ :c | c getNroContrato = nroContrato  ].	valor := unCliente cancelarContrato:  contrato.	 ].^valor! !!EmpresaTurismo methodsFor: 'para contratos'!pagarCuotas: nroContrato cant: cantCuotas"dado un numero de contrato y una cantidad de cuotas que el cliente desee pagarel metodo devuelve el total a pagar"| cli  valor contrato |valor:=0."verifico que existe un cliente con ese contrato"cli := colClientes detect: [ :cliente | (contrato := cliente obtenerContrato: nroContrato) notNil ] ifNone:  [ nil ].cli ifNotNil: [ 					"si el contrato no esta vencido, no esta dado de baja y puede ser posible pagar esa cantidad de cuotas deseadas"	(contrato vencido)	 ifFalse: [ 			(contrato getBaja)ifFalse: [ 				(contrato verifCuotas: cantCuotas) ifTrue: [					"si es posible pagar esas cuotas, lo hace"					valor := contrato pagar.			] .		].		valor := valor*cantCuotas.		].	 ].^valor! !!EmpresaTurismo methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/28/2023 02:31'!agregarJornada: unViajeOrganizado jornada: unaFechaunViajeOrganizado nuevaJornada: unaFecha .! !!EmpresaTurismo methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/27/2023 22:43'!agregarCliente: unClientecolClientes add:unCliente."agrego un cliente a mi coleccion"! !!EmpresaTurismo methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/27/2023 22:44'!agregarEtapa: unViaje etapa: unaEtapaunViaje nuevaEtapa: unaEtapa."Dado un viaje organizado agrego una etapa"! !!EmpresaTurismo methodsFor: 'accessing - implementations' stamp: 'Ernesto 1/11/2024 20:41'!verifCliente:dni|unCliente|"si encuentra un cliente con ese dni lo devuelve, sino devuelve nil"unCliente := colClientes detect: [:cliente| (cliente getDni) = dni] ifNone: [ nil ].^unCliente ! !!EmpresaTurismo methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/28/2023 02:43'!agregarViaje:unViaje"agrega el viaje a la coleccion"colViajes add:unViaje.! !!EmpresaTurismo methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/21/2024 17:19'!mostrarInfoViajes: fecha1 y: fecha2"crea una coleccion con viajes que esten entre esas 2 fechas y muestra la informacion de los mismos"|colNueva|colNueva := colViajes select: [ :viaje  | viaje viajesEn: fecha1 y: fecha2].^colNueva ! !!EmpresaTurismo methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/18/2024 14:31'!obtenerViaje: nombreViaje"devuelve el viaje con ese nombre o nil"|viaje|viaje := colViajes detect: [ :v | v getNombreViaje = nombreViaje  ] ifNone: [ nil ].^viaje ! !!EmpresaTurismo methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/23/2024 14:53'!iniciarDia"este metodo se utiliza todos los dias al iniciar el diacrea una coleccion con clientes que tienen contratos por vencer y luego les genera el aviso"|colNueva|colNueva := colClientes select:[ :cliente | cliente contratoPorVencer].colNueva do:[:cliente | cliente generarAviso]."posteriormente llama a efectivizacion contrato para que modifique esos contratos que han sido efectivo"self efectivizacionContrato .! !!EmpresaTurismo methodsFor: 'initialize' stamp: 'Ernesto 7/9/2023 23:53'!inicializarcolClientes := OrderedCollection new.colViajes := OrderedCollection new.! !!EmpresaTurismo methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:43'!setColClientes: anObject	colClientes := anObject! !!EmpresaTurismo methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:43'!setColViajes: anObject	colViajes := anObject! !!EmpresaTurismo methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:42'!getColClientes	^ colClientes! !!EmpresaTurismo methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:42'!getColViajes	^ colViajes! !!EmpresaTurismo methodsFor: 'as yet unclassified' stamp: 'Ernesto 1/17/2024 10:38'!transformarCliente: unCliente"en caso de ser posibleFrecuente = true y esFrecuente = true ---> ya es frecuente no tengo que modificarlo si posibleFrecuente = false y esFrecuente = false ---> ya es cliente comun. En ambos casos devuelve 'nil' "| clienteTransformado |(unCliente posibleFrecuente) ifTrue: [  "si tiene viajes organizados en un año"	(unCliente esFrecuente) ifFalse:["y no es un viajeroFrecuente"		clienteTransformado := unCliente transformar. "<-- este transformar devuelve un viajeroFrecuente"		]	 ] ifFalse: [ "si no tiene viajes organizados en un año"	(unCliente esFrecuente) ifTrue: [ " y es frecuente"		clienteTransformado := unCliente transformar." perdera el privilegio y sus millas, este transformar devuelve un Cliente comun"		 ]	 ].^clienteTransformado! !!EmpresaTurismo methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/21/2024 05:40'!precioPlus: nroContrato|valor cli contrato|cli := colClientes detect: [ :cliente | (cliente obtenerContrato: nroContrato) notNil ] ifNone: [ nil ].cli ifNotNil: [ 	contrato := cli getColContratos detect: [ :c | c getNroContrato = nroContrato  ].	contrato esFlex ifTrue: [ valor := contrato getPlus. ]		 ].^valor! !!EmpresaTurismo methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/19/2024 18:18'!bajaViaje: unViaje"Este metodo es para dar de baja a un viaje. A cada cliente que vaya a viajar a ese viaje le da de baja el contrato y les avisa que un contrato fue dado de baja"|colCli|colCli := colClientes select:[:cliente | cliente viajaA: unViaje].colCli ifNotNil: [ 	colCli do: [ :cliente | cliente bajarContratos: unViaje.		 cliente generarAvisoBaja] ].colViajes remove: unViaje .! !!EmpresaTurismo methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/16/2024 22:58'!mostrarContratos: dni|cliente|cliente := colClientes detect: [ :c | c getDni = dni ].^cliente getColContratos.! !!EmpresaTurismo methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/18/2024 14:54'!crearContratoFlexible: dni viaje: nombreViaje cant:personas f:unaFecha|unCliente rta unViaje aux|rta:=false.unCliente := self verifCliente: dni.unViaje := self obtenerViaje: nombreViaje.unCliente ifNotNil: [ 	unViaje ifNotNil: [ 	(unViaje verifViaje: personas fecha:  unaFecha) ifTrue: [				"mismo codigo pero genero contrato flexible"			unCliente generarContratoFlexible: unViaje personas: personas fecha: unaFecha.		rta:=true.		aux := self transformarCliente: unCliente.		aux ifNotNil: [ 						colClientes remove: unCliente .			colClientes add: aux.			 ]		] 	 ]. ].^rta! !!EmpresaTurismo methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/21/2024 05:45'!reprogramacionContrato: nroContrato fecha: nuevaFecha"dado un nro de contrato, busca ese contrato y si existe lo reprograma."|unCliente ret contrato |ret:= false.unCliente := colClientes detect: [ :cliente | (cliente obtenerContrato: nroContrato) notNil ] ifNone: [ nil ].unCliente ifNotNil: [ 	 		contrato := unCliente getColContratos detect: [ :c | c getNroContrato = nroContrato  ].		contrato ifNotNil: [ 			"te"	 ret := (unCliente reprogramarContrato: contrato  fecha: nuevaFecha) ifTrue: [ true ] ifFalse: [ false ] "reprogramarContrato devuelve T/F"	 ]	 ].^ret! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmpresaTurismo class	instanceVariableNames: ''!!EmpresaTurismo class methodsFor: 'as yet unclassified' stamp: 'Ernesto 7/9/2023 23:53'!crear|unaEmpresa|unaEmpresa := self new.unaEmpresa inicializar .^unaEmpresa .! !Object subclass: #Etapa	instanceVariableNames: 'actividades diaLlegada hotel tipoPension cantDias'	classVariableNames: ''	package: 'TPO-Clases'!!Etapa methodsFor: 'initialization' stamp: 'Ernesto 7/9/2023 23:59'!inicializar: nActividades d_llegada: nDia elHotel: nHotel pension: nTipoPension dias: nCantDiasactividades := nActividades .diaLlegada := nDia.hotel := nHotel .tipoPension := nTipoPension .cantDias := nCantDias .! !!Etapa methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:51'!setHotel: anObject	hotel := anObject! !!Etapa methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:51'!setActividades: anObject	actividades := anObject! !!Etapa methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:45'!getTipoPension	^ tipoPension! !!Etapa methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:51'!setDiaLlegada: anObject	diaLlegada := anObject! !!Etapa methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:45'!getHotel	^ hotel! !!Etapa methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:45'!getDiaLlegada	^ diaLlegada! !!Etapa methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:44'!getActividades	^ actividades! !!Etapa methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:57'!setTipoPension: anObject	tipoPension := anObject! !!Etapa methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:45'!getCantDias	^ cantDias! !!Etapa methodsFor: 'accessing' stamp: 'Ernesto 7/10/2023 00:51'!setCantDias: anObject	cantDias := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Etapa class	instanceVariableNames: ''!!Etapa class methodsFor: 'as yet unclassified' stamp: 'Ernesto 7/10/2023 00:00'!crear: nActividades d_llegada: nDia elHotel: nHotel pension: nTipoPension dias: nCantDias|unaEtapa|unaEtapa := self new.unaEtapa inicializar: nActividades d_llegada: nDia elHotel: nHotel pension: nTipoPension dias: nCantDias.^unaEtapa.! !Object subclass: #ExcursionContratada	instanceVariableNames: 'excursion cantPersonas'	classVariableNames: ''	package: 'TPO-Clases'!!ExcursionContratada methodsFor: 'initialization' stamp: 'Ernesto 8/3/2023 10:57'!inicializar: nExcursion personas: personasexcursion := nExcursion .cantPersonas := personas.! !!ExcursionContratada methodsFor: 'accessing' stamp: 'Ernesto 8/4/2023 23:38'!getPersonasContratadas	^ cantPersonas! !!ExcursionContratada methodsFor: 'accessing' stamp: 'Ernesto 8/4/2023 23:38'!setPersonasContratadas: anObject	cantPersonas := anObject! !!ExcursionContratada methodsFor: 'accessing' stamp: 'Ernesto 8/4/2023 23:38'!getExcursion	^ excursion! !!ExcursionContratada methodsFor: 'accessing' stamp: 'Ernesto 8/4/2023 23:38'!setExcursion: anObject	excursion := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExcursionContratada class	instanceVariableNames: ''!!ExcursionContratada class methodsFor: 'as yet unclassified' stamp: 'Ernesto 8/3/2023 11:19'!crear: nExcursion personas: personas|excursionContratada|excursionContratada := self new.excursionContratada inicializar: nExcursion personas: personas.^excursionContratada ! !Object subclass: #ExcursionOpcional	instanceVariableNames: 'precio nombre cupo cantMaxima'	classVariableNames: ''	package: 'TPO-Clases'!!ExcursionOpcional methodsFor: 'accessing' stamp: 'Ernesto 1/17/2024 10:46'!inicializar: nNombre price: nPrecio cantPer: nPersonasnombre:=nNombre .precio:=nPrecio .cantMaxima  := nPersonas .cupo := cantMaxima . "variable que se va a ir modificando en caso de contratar la excursion"! !!ExcursionOpcional methodsFor: 'accessing' stamp: 'Ernesto 7/29/2023 01:57'!getNombreExcursion^nombre ! !!ExcursionOpcional methodsFor: 'accessing' stamp: 'Ernesto 8/4/2023 23:20'!getPersonas^cupo  ! !!ExcursionOpcional methodsFor: 'accessing' stamp: 'Ernesto 7/12/2023 20:52'!setPrecio: anObject precio := anObject ! !!ExcursionOpcional methodsFor: 'accessing' stamp: 'Ernesto 7/12/2023 20:53'!setNombre: anObjectnombre := anObject ! !!ExcursionOpcional methodsFor: 'accessing' stamp: 'Ernesto 7/12/2023 20:52'!getPrecio^precio ! !!ExcursionOpcional methodsFor: 'accessing' stamp: 'Ernesto 8/4/2023 23:20'!setPersonas: anObjectcupo  := anObject ! !!ExcursionOpcional methodsFor: 'as yet unclassified' stamp: 'Ernesto 8/4/2023 23:20'!excursionDisponible: personas|rta|rta := false.(cupo - personas >= 0)ifTrue: [ 	rta := true. 	cupo := cupo - personas .	].^rta ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExcursionOpcional class	instanceVariableNames: ''!!ExcursionOpcional class methodsFor: 'as yet unclassified' stamp: 'Ernesto 7/12/2023 21:21'!crear: nNombre price: nPrecio cantPer: nPersonas|unaExcursion|unaExcursion := self new.unaExcursion inicializar: nNombre price: nPrecio cantPer: nPersonas.^unaExcursion ! !Object subclass: #Jornada	instanceVariableNames: 'fecha cupo disponible'	classVariableNames: ''	package: 'TPO-Clases'!!Jornada methodsFor: 'as yet unclassified' stamp: 'Ernesto 8/3/2023 11:02'!getDisponible ^disponible ! !!Jornada methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/18/2024 14:51'!estaDisponible: personas|disp|disp:=disponible & (cupo-personas >= 0).^disp! !!Jornada methodsFor: 'accessing - implementations' stamp: 'Ernesto 8/4/2023 13:14'!devolverCupos: personascupo:= cupo+personas.disponible:=true! !!Jornada methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/18/2024 14:53'!actualizarJornada: personascupo:= cupo-personas.! !!Jornada methodsFor: 'initialization' stamp: 'Ernesto 7/15/2023 21:34'!inicializar: nFecha cant: nCuposfecha := nFecha.cupo := nCupos.disponible := true.! !!Jornada methodsFor: 'accessing' stamp: 'Ernesto 7/15/2023 21:43'!getFecha^fecha ! !!Jornada methodsFor: 'accessing' stamp: 'Ernesto 7/15/2023 21:44'!setCupo: nCupocupo := nCupo.! !!Jornada methodsFor: 'accessing' stamp: 'Ernesto 7/15/2023 21:44'!getCupo^cupo ! !!Jornada methodsFor: 'accessing' stamp: 'Ernesto 7/15/2023 21:43'!setFecha: nFechafecha := nFecha .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Jornada class	instanceVariableNames: ''!!Jornada class methodsFor: 'as yet unclassified' stamp: 'Ernesto 7/15/2023 21:39'!crear: nFecha cant: nCupos|unaFecha|unaFecha := self new.unaFecha inicializar: nFecha cant: nCupos.^unaFecha! !Object subclass: #Viaje	instanceVariableNames: 'nombre costoImpuestos costoPorPersona cantMaximaPersonas'	classVariableNames: ''	package: 'TPO-Clases'!!Viaje methodsFor: 'as yet unclassified' stamp: 'Ernesto 12/25/2023 18:07'!esOrganizadoself subclassResponsibility ."Retorna true si es un ViajeOrganizado y false si es ViajeEspecial"! !!Viaje methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 18:18'!viajesEn: fecha1 y: fecha2self subclassResponsibility "Retorna true si el viaje esta entre esas fechas y false en caso contrario"! !!Viaje methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 18:14'!verifViaje: personas fecha:unaFechaself subclassResponsibility " Dada una fecha y una cantidad de personas, verifica si es posible contratar ese viaje"! !!Viaje methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 18:14'!obtenerValor|valor|valor := self getCostoPorPersona .valor := valor + costoImpuestos .^valor"Devuelve el costo del viaje"! !!Viaje methodsFor: 'accessing - implementations' stamp: 'Ernesto 7/13/2023 11:01'!mostrarInfoself subclassResponsibility ! !!Viaje methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 18:08'!obtenerExcursion: nombreExcursionself subclassResponsibility ."Dado un nombre, retorna la Excursion con ese nombre si la encuentra, si no la encuentra retorna null"! !!Viaje methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 18:10'!obtenerJornada: unaFechaself subclassResponsibility ." Dada una fecha retorna la Jornada con esa fecha si la cuentra, si no la encuentra retorna null"! !!Viaje methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 01:19'!esReprogramable: cantPersonas fecha: nuevaFechaself subclassResponsibility . "Retorna T/F en caso de que exista una Jornada con esa fecha en caso de un ViajeOrganizado, retorna true en caso de un ViajeEspecial y lo reprograma con otra fecha"! !!Viaje methodsFor: 'accessing' stamp: 'Ernesto 7/29/2023 01:57'!getNombreViaje	^ nombre! !!Viaje methodsFor: 'accessing' stamp: 'Ernesto 7/13/2023 10:29'!setCostoImpuestos: anObjectcostoImpuestos := anObject  ! !!Viaje methodsFor: 'accessing' stamp: 'Ernesto 7/23/2023 21:22'!setCostoPorPersona: preciocostoPorPersona := precio.! !!Viaje methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 10:09'!setNombre: anObject	nombre := anObject! !!Viaje methodsFor: 'accessing' stamp: 'Ernesto 7/13/2023 02:04'!getCostoPorPersona^costoPorPersona ! !!Viaje methodsFor: 'accessing' stamp: 'Ernesto 7/13/2023 10:28'!getCostoImpuestos^costoImpuestos ! !!Viaje methodsFor: 'initialization' stamp: 'Ernesto 8/3/2023 04:14'!inicializar: nNombre imp: nImpuestos costo: xPersona cantPersonas: personascantMaximaPersonas := personas.costoPorPersona := xPersona.nombre:= nNombre .costoImpuestos := nImpuestos.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Viaje class	instanceVariableNames: ''!!Viaje class methodsFor: 'as yet unclassified' stamp: 'Ernesto 8/3/2023 04:15'!crear: nNombre imp: nImpuestos costo: xPersona cantPersonas: personas|unViaje|unViaje := self new.unViaje inicializar: nNombre imp: nImpuestos costo: xPersona cantPersonas: personas.^unViaje .! !Viaje subclass: #Especial	instanceVariableNames: 'ciudad salida fecha_regreso'	classVariableNames: ''	package: 'TPO-Clases'!!Especial methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/21/2024 17:20'!viajesEn: fecha1 y: fecha2	| fechaViaje rta |	fechaViaje := salida getFecha.	rta := salida getDisponible and:		       (fechaViaje between: fecha1 and: fecha2).	^ rta	"Si la fecha de salida esta entre las dos fechas indicadas, retorna true para que posteriormente se muestre la info de este viaje"! !!Especial methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/18/2024 14:45'!verifViaje: personas fecha: unaFecha|rta| rta := false. (unaFecha = salida getFecha) ifTrue: [	rta := salida estaDisponible: personas].^rta"Verifica que la fecha de salida sea igual a la fecha que el cliente busca viajar, si es asi, verifica que hayan cupos para ese viaje. De ser asi retorna true."! !!Especial methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 18:35'!obtenerExcursion: nombreExcursion^nil."Como las excursiones son solo para viajes organizados, retorna null"! !!Especial methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/25/2024 14:46'!mostrarInfo |string|string:='Viaje: ', nombre, ', Organizado?: ', self esOrganizado asString , ', en ', ciudad , ', salida el: ', (salida getFecha) asString , ', regreso el: ', fecha_regreso asString .^string! !!Especial methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 01:25'!obtenerJornada: unaFecha^salida "* Como los viajes especiales tienen una sola Jornada y esta dada a una fecha * que el Cliente dio, no es necesario hacer ninguna verificacion, simplemente * se retorna la Jornada 'fechaSalida' para posteriormente cambiarle la fecha o modificar sus cupos"! !!Especial methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 01:19'!esReprogramable: cantPersonas fecha: nuevaFecha|difDias|difDias := fecha_regreso -(salida getFecha) .salida setFecha: nuevaFecha .fecha_regreso := nuevaFecha addDays: difDias asDays .^true"Al reprogramar no deberia verificar si hay cupos para esa fecha debido a quesimplemente le cambian la fecha. entonces no utilizo 'cantPersonas'"! !!Especial methodsFor: 'initialization' stamp: 'Ernesto 8/3/2023 20:11'!inicializar: nNombre f_salida: nFecha ciudad: nCiudad f_vuelta: nFechaVuelta imp: nImpuestos costo: xPersona cantPersonas: personasself inicializar: nNombre imp: nImpuestos costo: xPersona cantPersonas: personas. salida := Jornada crear: nFecha cant:  personas.ciudad := nCiudad .fecha_regreso := nFechaVuelta .! !!Especial methodsFor: 'accessing' stamp: 'Ernesto 8/3/2023 20:10'!setFecha_salida: unaFecha	salida setFecha:unaFecha.! !!Especial methodsFor: 'accessing' stamp: 'Ernesto 7/28/2023 05:29'!getFecha_regreso	^ fecha_regreso! !!Especial methodsFor: 'accessing' stamp: 'Ernesto 7/28/2023 05:29'!setFecha_regreso: anObject	fecha_regreso := anObject! !!Especial methodsFor: 'accessing' stamp: 'Ernesto 8/3/2023 20:11'!getFecha_salida ^salida getFecha! !!Especial methodsFor: 'accessing' stamp: 'Ernesto 7/28/2023 05:29'!getCiudad	^ ciudad! !!Especial methodsFor: 'accessing' stamp: 'Ernesto 7/28/2023 05:29'!setCiudad: anObject	ciudad := anObject! !!Especial methodsFor: 'as yet unclassified' stamp: 'Ernesto 12/25/2023 18:34'!esOrganizado ^false." Como es un ViajeEspecial, retorna false"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Especial class	instanceVariableNames: ''!!Especial class methodsFor: 'as yet unclassified' stamp: 'Ernesto 8/3/2023 04:15'!crear: nNombre f_salida: nFecha  ciudad: nCiudad f_vuelta: nFechaVuelta imp: nImpuestos costo: xPersona cantPersonas: personas|auxEspecial|auxEspecial := self new.auxEspecial inicializar: nNombre f_salida: nFecha ciudad: nCiudad f_vuelta: nFechaVuelta imp: nImpuestos costo: xPersona cantPersonas: personas.^auxEspecial .! !Viaje subclass: #Organizado	instanceVariableNames: 'duracion colEtapas colJornadas excursionesOpcionales'	classVariableNames: ''	package: 'TPO-Clases'!!Organizado methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/21/2024 18:24'!agregarExcursion: nombreExcursion precio: nPrecio cantPer: personas" nNombre price: nPrecio cantPer: nPersonas"|excursion|excursion := ExcursionOpcional crear: nombreExcursion  price: nPrecio  cantPer: personas.excursionesOpcionales add: excursion.^true! !!Organizado methodsFor: 'as yet unclassified' stamp: 'Ernesto 2/21/2024 17:02'!mostrarJornadas: coleccion    | string pos|	 string := '['.    coleccion do: [ :fecha |         string := string, fecha getFecha asString, ' / '.        ].	string := string, ']'.pos := string lastSpacePosition. string := string copyReplaceFrom: pos to: pos with: ''.pos := pos-1. string := string copyReplaceFrom: pos to: pos with: ''.pos := pos-1. string := string copyReplaceFrom: pos to: pos with: ''.^string! !!Organizado methodsFor: 'initialization' stamp: 'Ernesto 8/3/2023 04:16'!inicializar: nNombre etapas: nEtapas imp: nImpuestos costo: xPersona cantPersonas: personasself inicializar: nNombre  imp: nImpuestos costo: xPersona cantPersonas: personas.colEtapas :=nEtapas.colJornadas  := OrderedCollection new.excursionesOpcionales  := OrderedCollection new .self calcularDuracion.! !!Organizado methodsFor: 'accessing' stamp: 'Ernesto 7/28/2023 02:02'!getDuracion	^ duracion! !!Organizado methodsFor: 'accessing' stamp: 'Ernesto 7/28/2023 02:02'!getColEtapas	^ colEtapas! !!Organizado methodsFor: 'accessing' stamp: 'Ernesto 8/1/2023 00:36'!getExcursionesOpcionales^excursionesOpcionales  ! !!Organizado methodsFor: 'accessing' stamp: 'Ernesto 7/28/2023 02:02'!setColEtapas: anObject	colEtapas := anObject! !!Organizado methodsFor: 'accessing' stamp: 'Ernesto 7/28/2023 02:02'!setDuracion: anObject	duracion := anObject! !!Organizado methodsFor: 'accessing' stamp: 'Ernesto 12/25/2023 18:26'!calcularDuracionduracion:=0.colEtapas do: [ :etapa| duracion:=duracion + etapa getCantDias ]."La duracion de un ViajeOrganizado esta determinada por la suma de la duracion de todas sus Etapas"! !!Organizado methodsFor: 'accessing' stamp: 'Ernesto 8/1/2023 00:37'!setExcursionesOpcionales: colExcursionesexcursionesOpcionales  := colExcursiones  ! !!Organizado methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 18:33'!nuevaJornada: unaFecha|unaJornada|unaJornada := Jornada crear: unaFecha  cant: cantMaximaPersonas .colJornadas add: unaJornada ."Se utiliza para agregar una nueva Jornada al viaje"! !!Organizado methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 18:30'!verifViaje: personas fecha:unaFecha|unaJornada rta|rta:=false.unaJornada := colJornadas detect: [ :jornada | (jornada getFecha)=unaFecha  ] ifNone: [ nil ].unaJornada ifNotNil: [ 	(unaJornada estaDisponible: personas) ifTrue: [		rta:=true]	 ].^rta "Verifica que alguna de sus Jornadas esten en una fecha ingresada y en caso positivo de que la en cuentre se devuelve la Jornada, si la misma esta disponible para la cantidad de personas ingresadas, retorna true."! !!Organizado methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 18:27'!esOrganizado ^true."Como es un ViajeOrganizado, retorna true"! !!Organizado methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/21/2024 17:24'!viajesEn: fecha1 y: fecha2| unaJornada rta|rta:=false.unaJornada:=colJornadas  detect:[:jornada | (jornada getDisponible) and:		       ((jornada getFecha) between: fecha1 and: fecha2)] ifNone: [nil].unaJornada ifNotNil:[rta:=true].^rta"Este modulo es utilizado para mostrar la info de todos los viajes que esten entre esas dos fechas y para saber si el Cliente es ViajeroFrecuente.  En caso de los ViajesOrganizados, si alguna Jornada se encuentra entre esas fechas, corta la busqueda y devuelve true para que despues se muestre toda la info del viaje"! !!Organizado methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 01:57'!obtenerExcursion: nombreExcursion|ret|ret  := excursionesOpcionales detect: [ :excursion | (excursion getNombreExcursion) = nombreExcursion  ] ifNone:[ nil ].^ret"Si encuentra a la excursion con ese nombre la devuelve, sino devuelve null"! !!Organizado methodsFor: 'accessing - implementations' stamp: 'Ernesto 2/25/2024 14:46'!mostrarInfo |string aux|aux:= self mostrarJornadas: colJornadas .string:='Viaje: ', nombre , ', Organizado?: ', self esOrganizado asString, ', Duracion: ', duracion asString ,' dias, para ', cantMaximaPersonas asString ,' personas, salidas: ', aux.^string! !!Organizado methodsFor: 'accessing - implementations' stamp: 'Ernesto 8/3/2023 05:58'!obtenerJornada: unaFecha|unaJornada|unaJornada := colJornadas  detect: [ :fecha | fecha getFecha = unaFecha ].^unaJornada ."como este metodo lo uso para cancelar un contrato no utilizo el 'ifNone:' porque ya se que esa fecha existe"! !!Organizado methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/25/2023 18:33'!nuevaEtapa: unaEtapacolEtapas add: unaEtapa ."Se utiliza para agregar una nueva etapa al viaje"! !!Organizado methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/26/2023 01:22'!esReprogramable:  cantPersonas fecha: nuevaFecha^self verifViaje:  cantPersonas fecha: nuevaFecha ."Como el viaje organizado tiene varias Jornadas(fechas) entonces  busco si hay cupos para esa fecha(si es que existe con esa fecha)"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Organizado class	instanceVariableNames: ''!!Organizado class methodsFor: 'as yet unclassified' stamp: 'Ernesto 8/3/2023 04:16'!crear:  nNombre etapas: nEtapas imp: nImpuestos costo: xPersona cantPersonas: personas|auxOrganizado|auxOrganizado := self new.auxOrganizado inicializar:  nNombre etapas: nEtapas imp: nImpuestos costo: xPersona cantPersonas: personas.^auxOrganizado .! !Cliente subclass: #ViajeroFrecuente	instanceVariableNames: 'millas'	classVariableNames: ''	package: 'TPO-Clases'!!ViajeroFrecuente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:46'!getMillas	^ millas! !!ViajeroFrecuente methodsFor: 'accessing' stamp: 'Ernesto 7/9/2023 09:46'!setMillas: anObject	millas := anObject! !!ViajeroFrecuente methodsFor: 'accessing - implementations' stamp: 'Ernesto 8/5/2023 01:34'!esFrecuente ^true! !!ViajeroFrecuente methodsFor: 'accessing - implementations' stamp: 'Ernesto 1/11/2024 22:28'!yaViajo |cant|"cant es la cantidad de contratos efectivos que encontro en colContratos y paso a colContratosEfectivos"cant:=super yaViajo ."si tuvo al menos un contrato efectivo en esa revision, que sume las millas necesarias"(cant>0)ifTrue: [ millas:=millas+(100*cant). ].^cant! !!ViajeroFrecuente methodsFor: 'accessing - implementations' stamp: 'Ernesto 1/18/2024 10:58'!cancelarContrato: unContrato|valor aux|"cancelarContrato devuelve el valor a devolver segun cuanto falte para el viaje desde la cancelacion del mismo"valor := super cancelarContrato: unContrato ."si tiene mas de 500 millas entonces cancelo el 10% de ese contrato con millas"(millas >= 500) ifTrue: [ 	"aux seria justamente ese 10% que el cliente 'pagaria' con las millas, entonces se le devolveria esa plata "	aux := unContrato valorPagado*0.10 .	valor := valor+aux.	millas := millas - 500.	 ].^valor! !!ViajeroFrecuente methodsFor: 'accessing - implementations' stamp: 'Ernesto 12/27/2023 13:01'!transformar| cliente |cliente := Cliente crear: dni ape: apellido city: ciudadOrigen  correo: mail tel: telefono  pref: preferencias."si no tiene contratos, es como crearlo de nuevo"(colContratos size + colContratosEfectivos size =0) ifTrue: [  	cliente setColContratos: colContratos .	cliente setColContratosEfectivos: colContratosEfectivos . 	].^cliente! !!ViajeroFrecuente methodsFor: 'initialization' stamp: 'Ernesto 7/10/2023 00:17'!inicializar: nDni ape: nApellido city: nCiudad correo: nMail tel: nTelefono pref: nPreferenciassuper inicializar: nDni ape: nApellido city: nCiudad correo: nMail tel: nTelefono pref: nPreferencias.millas:=0.! !